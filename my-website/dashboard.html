<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Dashboard</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%F0%9F%93%9A%3C/text%3E%3C/svg%3E" />
    <style>
      :root { --bg:#0b1020; --panel:#0e1430; --card:#11162a; --muted:#9aa4b2; --text:#e6eaf2; --accent:#7c3aed; --accent2:#667eea; --border:#23304d; }
      html, body { height:100%; }
      body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:linear-gradient(180deg,#0b1020,#0e1530 40%, #0a0f25); color:var(--text); }
      header { padding:18px 20px; }
      .head { max-width:1200px; margin:0 auto; display:flex; align-items:center; justify-content:space-between; gap:12px; }
      .title { font-size:clamp(18px, 2.6vw, 28px); font-weight:700; letter-spacing:.2px; }
      .sub { color:var(--muted); margin-top:4px; font-size:13px; }
  .shell { max-width:1400px; margin:0 auto 20px; padding:0 16px 20px; display:grid; grid-template-columns: 230px 1fr 330px; gap:16px; }
      @media (max-width: 1100px) { .shell { grid-template-columns: 1fr; } }
  .side { background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)); border:1px solid var(--border); border-radius:14px; padding:14px; -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
  .nav { display:flex; flex-direction:column; gap:8px; }
  .nav button { text-align:left; background:transparent; border:1px solid var(--border); color:var(--text); padding:10px 12px; border-radius:10px; cursor:pointer; }
  .nav button:hover, .nav button.active { background: rgba(124,58,237,.12); border-color:#5b21b6; }
  .nav .nav-admin { border-color:#7f1d1d; color:#fecaca; }
  .nav .nav-admin:hover, .nav .nav-admin.active { background: rgba(239,68,68,.15); border-color:#ef4444; }
  /* Student View: hide admin-only UI when toggled by admins */
  body.student-view #manageGroupsBtn,
  body.student-view #manageGroupsCard,
  body.student-view #attendanceAdmin,
  body.student-view #portfolioAdmin,
  body.student-view #specsAdmin,
  body.student-view #specsAdminActionsHead,
  body.student-view #seedPortfolioBtn,
  body.student-view .nav .nav-admin { display:none !important; }
  body.student-view #specsTable th:nth-child(5),
  body.student-view #specsTable td:nth-child(5) { display:none !important; }
      .main { display:flex; flex-direction:column; gap:16px; }
  .card { background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); border:1px solid var(--border); border-radius:14px; padding:14px; -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
  .card h2 { margin:0 0 6px; font-size:16px; display:inline-block; background:#ffffff; color:#0e0f14; padding:6px 10px; border-radius:10px; box-shadow: 0 2px 10px rgba(0,0,0,.08); }
      .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .muted { color: var(--muted); }
      .right { display:flex; flex-direction:column; gap:16px; }
      .kvs { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
      .kv { background:rgba(255,255,255,.02); border:1px solid var(--border); border-radius:10px; padding:10px; }
      .kv .k { font-size:12px; color:var(--muted); }
      .kv .v { font-weight:700; }
      table { width:100%; border-collapse: collapse; }
      th, td { padding:8px 10px; border-bottom:1px solid var(--border); font-size:14px; }
      th { text-align:left; color:#cfd7e6; font-weight:600; }
      .tag { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border); }
      .tag.ok { background: rgba(16,185,129,.15); border-color:#065f46; color:#a7f3d0; }
      .tag.warn { background: rgba(245,158,11,.15); border-color:#92400e; color:#fde68a; }
      .tag.err { background: rgba(239,68,68,.15); border-color:#7f1d1d; color:#fecaca; }
      button { background: transparent; border:1px solid var(--border); color:var(--text); padding:8px 12px; border-radius:10px; cursor:pointer; }
      button:hover { background: rgba(124,58,237,.12); border-color:#5b21b6; }
  /* Profile */
  .profile-wrap { display:grid; grid-template-columns: 240px 1.2fr 1.8fr; gap:16px; }
  @media (max-width: 900px) { .profile-wrap { grid-template-columns: 1fr; } }
  .avatar { width:180px; height:180px; border-radius:50%; border:2px solid var(--border); background:#0c1228; object-fit:cover; display:block; }
  .avatar-wrap { display:flex; flex-direction:column; align-items:center; gap:10px; }
  .profile-form { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:12px; grid-column: 1 / -1; }
  .profile-form label { font-size:14px; display:block; }
  .profile-form input, .profile-form textarea { width:100%; font-size:15px; padding:10px 12px; border:1px solid #d0d5dd; border-radius:10px; background:#ffffff; color:#0e0f14; box-sizing:border-box; }
  .profile-form textarea { min-height: 90px; }
  .profile-actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  /* Read-only summary card shown next to avatar */
  .profile-summary { background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:10px; padding:12px; font-size:14px; line-height:1.5; }
  .profile-summary > div { margin-bottom:6px; }
  /* In view mode, let summary span the remaining width (both right columns) */
  #profileCard.view-mode .profile-summary { grid-column: 2 / -1; }
  .profile-summary strong { color:#e6eaf2; }
  .profile-summary .muted { color: var(--muted); }
  .camera-wrap { display:none; flex-direction:column; gap:8px; align-items:center; padding:10px; border:1px dashed var(--border); border-radius:10px; }
  video#cameraVideo { width: 260px; max-width: 90%; border-radius:10px; background:#000; }
  /* Class Profiles */
  .profiles-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap:12px; }
  /* Compact class profile cards: at least 4 per row on ~800px content width */
  .profile-card { background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:12px; padding:12px; display:grid; grid-template-columns: 1fr; gap:8px; cursor:pointer; box-sizing:border-box; min-height: 240px; }
  .profile-card:hover { background: rgba(124,58,237,.08); border-color:#5b21b6; }
  .profile-card .meta { display:flex; flex-direction:column; gap:6px; overflow:hidden; align-items:center; text-align:center; }
  .profile-card .lines { color:#cbd5e1; font-size:13px; line-height:1.35; display:-webkit-box; -webkit-line-clamp:4; line-clamp:4; -webkit-box-orient: vertical; overflow:hidden; }
  .profile-card .actions { margin-top:auto; }
  .profile-card button.view-more { padding:6px 10px; font-size:13px; }
  .profile-sm { width:72px; height:72px; border-radius:50%; border:1px solid var(--border); object-fit:cover; background:#0c1228; margin:0 auto; }
  .profile-name { font-weight:700; text-align:center; }
  .profile-section { font-size:12px; color:var(--muted); }
      /* Peer Reviews: larger, white typing areas for readability */
  #peerReviewsCard label, #reflectionsCard label { font-size:14px; display:block; }
  #peerReviewsCard input[type="text"],
  #peerReviewsCard input[type="email"],
  #peerReviewsCard input[type="file"],
  #peerReviewsCard select,
  #peerReviewsCard textarea,
  #reflectionsCard input[type="text"],
  #reflectionsCard input[type="email"],
  #reflectionsCard input[type="file"],
  #reflectionsCard select,
  #reflectionsCard textarea {
        font-size:16px;
        padding:12px 14px;
        border:1px solid #d0d5dd;
        border-radius:10px;
        background:#ffffff;
        color:#0e0f14;
        width:100%;
        max-width:100%;
        box-sizing:border-box;
        display:block;
      }
  #peerReviewsCard textarea, #reflectionsCard textarea { min-height: 200px; line-height: 1.5; }
  #peerReviewsCard input[type="file"], #reflectionsCard input[type="file"] { padding:8px 10px; }
      #peerReviewsCard input:focus,
      #peerReviewsCard select:focus,
      #peerReviewsCard textarea:focus { outline:none; border-color:#5b21b6; box-shadow:0 0 0 3px rgba(124,58,237,.18); }
      #peerReviewsCard button { padding:10px 14px; font-size:15px; }
  /* Simple modal */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index:1000; -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
  .modal-backdrop.show { display:flex; }
  .modal-dialog { background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); border:1px solid var(--border); border-radius:12px; padding:14px; width:min(720px, 92vw); color:var(--text); }
  .modal-dialog h3 { margin:0 0 8px; font-size:16px; }
  .modal-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:10px; }
  .calendar { display:grid; grid-template-columns: repeat(7, 1fr); gap:4px; }
  .cal-head { display:grid; grid-template-columns: repeat(7, 1fr); gap:4px; font-size:12px; color:var(--muted); margin-bottom:6px; }
  .day { background:rgba(255,255,255,.02); border:1px solid var(--border); border-radius:8px; padding:4px; text-align:center; font-size:12px; }
      .day.today { outline: 2px solid var(--accent2); }
  .day .tag { font-size:10px; padding:1px 6px; }
  .day.no-class { opacity:.5; }
  .day .nc { font-size:10px; color: var(--muted); margin-top:2px; display:inline-block; }
      .code-box { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; border:1px solid var(--border); background:#0c1228; padding:8px 10px; border-radius:8px; display:inline-block; }
  /* Groups tab display */
  .group-box { background:rgba(255,255,255,.02); border:1px solid var(--border); border-radius:10px; padding:10px; }
  .group-box.my { border-color:#5b21b6; box-shadow:0 0 0 1px rgba(124,58,237,.35) inset; }
  .group-title { margin:0 0 6px; font-size:14px; display:flex; align-items:center; justify-content:space-between; }
  .group-members { list-style:none; padding-left:0; margin:6px 0 0; display:grid; gap:6px; }
  .group-member { background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:8px; padding:6px 8px; }
  /* Manage Groups */
  .mg-head { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
  .pills { display:flex; gap:6px; flex-wrap:wrap; }
  .pill { background:transparent; border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:999px; cursor:pointer; font-size:13px; }
  .pill.active { background: rgba(124,58,237,.15); border-color:#5b21b6; }
  .mg-grid { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:10px; }
  @media (max-width: 1100px) { .mg-grid { grid-template-columns: 1fr; } }
  .mg-group { background:rgba(255,255,255,.02); border:1px solid var(--border); border-radius:10px; padding:10px; }
  .mg-group h3 { margin:0 0 6px; font-size:14px; }
  .mg-cap { font-size:12px; color:var(--muted); }
  .mg-list { list-style:none; padding-left:0; margin:8px 0 0; display:grid; gap:6px; }
  .mg-unassigned { margin-bottom:10px; }
  .mg-student { background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:8px; padding:6px 8px; cursor:grab; }
  .drop-target { min-height: 40px; }
  /* Attendance chips */
  .att-chips { display:flex; flex-wrap:wrap; gap:6px; }
  .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,.02); font-size:13px; }
  .chip .d { color: var(--muted); }
  .chip .tag { font-size:11px; }
  /* Make the Mark Today button a white pill */
  #markAttendanceBtn { background:#ffffff; color:#0e0f14; border-color:#d0d5dd; box-shadow: 0 1px 0 rgba(0,0,0,.05); }
  #markAttendanceBtn:hover { background:#f8fafc; border-color:#94a3b8; }
  #markAttendanceBtn:disabled { background:#f1f5f9; color:#64748b; border-color:#cbd5e1; opacity:.7; cursor:not-allowed; }
    </style>
    <script src="./config.js?v=1"></script>
  </head>
  <body>
    <header>
      <div class="head">
        <div>
          <div class="title">Course Dashboard</div>
          <div class="sub">Authenticated area using your Supabase project</div>
        </div>
        <div>
          <button id="signOutBtn">Sign out</button>
          <button id="openDeploysBtn" class="nav-admin" title="Open Netlify Deploys" style="margin-left:8px; display:none;">Deploys</button>
        </div>
      </div>
    </header>
    <main class="shell">
      <aside class="side">
        <div class="nav">
          <button class="nav-btn" data-target="profile">Profile</button>
          <button class="nav-btn" data-target="attendance">Attendance</button>
          <button class="nav-btn" data-target="specs">Specifications</button>
          <button class="nav-btn" data-target="assignments">Assignments</button>
          <button class="nav-btn" data-target="peerReviews">Peer Reviews</button>
          <button class="nav-btn" data-target="reflections">Reflections</button>
          <button class="nav-btn" data-target="classProfiles">Class Profile</button>
          <!-- Extra (kept after requested order) -->
          <button class="nav-btn" data-target="groups">Groups</button>
          <button class="nav-btn" onclick="window.open('group-randomizer.html', '_blank')" title="Open standalone group randomizer">Group Randomizer</button>
          <button id="studentViewToggleBtn" title="Temporarily hide admin UI to preview the student experience">Student View</button>
          <button class="nav-btn nav-admin" id="manageGroupsBtn" data-target="manageGroups">Manage Groups (Admin)</button>
        </div>
      </aside>

      <section class="main">
        <div class="card" id="profileCard">
          <div class="row">
            <div>
              <div id="greeting">Loading…</div>
              <div class="muted" id="details"></div>
            </div>
            <div class="profile-actions">
              <button id="editProfileBtn" type="button" style="display:none;">Edit</button>
            </div>
          </div>
          <div class="profile-wrap" style="margin-top:10px;">
            <div class="avatar-wrap">
              <img id="profilePhoto" class="avatar" alt="Your headshot" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'%3E%3Crect width='160' height='160' rx='80' fill='%230c1228'/%3E%3Ctext x='50%' y='54%' dominant-baseline='middle' text-anchor='middle' font-size='54' fill='%239aa4b2'%3E%F0%9F%91%A4%3C/text%3E%3C/svg%3E" />
              <div id="profileEditMedia">
                <input type="file" id="profilePhotoFile" accept="image/*" capture="user" aria-label="Upload headshot" />
                <div class="profile-actions">
                  <button id="openCameraBtn" type="button">Open Camera</button>
                  <span class="muted" id="photoMsg"></span>
                </div>
                <div class="camera-wrap" id="cameraWrap">
                  <video id="cameraVideo" playsinline></video>
                  <div class="profile-actions">
                    <button id="capturePhotoBtn" type="button">Capture</button>
                    <button id="closeCameraBtn" type="button">Close</button>
                  </div>
                </div>
              </div>
            </div>
            <div id="profileSummary" class="profile-summary" aria-live="polite"></div>
            <form id="profileForm" class="profile-form">
              <label>Full name
                <input type="text" id="pfFullName" placeholder="Your full legal name" />
              </label>
              <label>Prefer to be called
                <input type="text" id="pfPreferName" placeholder="e.g., Jon" />
              </label>
              <label>Hometown
                <input type="text" id="pfHomebase" placeholder="Where is home?" />
              </label>
              <label>Previous Education
                <input type="text" id="pfPrevEdu" placeholder="School / program" />
              </label>
              <label style="grid-column:1 / -1;">Best days/times to meet
                <input type="text" id="pfBestTimes" placeholder="e.g., Tue/Thu afternoons" />
              </label>
              <label style="grid-column:1 / -1;">Favorite food and books
                <textarea id="pfFavFoodBooks" placeholder="Share a few favorites..."></textarea>
              </label>
              <label>Communication (preferred channels)
                <textarea id="pfComms" placeholder="1) ... 2) ... 3) ..."></textarea>
              </label>
              <label>Strong points
                <textarea id="pfStrong" placeholder="What are you great at?"></textarea>
              </label>
              <label>Topics you can advise on
                <textarea id="pfAdvice" placeholder="Classmates can ask me about..."></textarea>
              </label>
              <label>Goals (next year)
                <textarea id="pfGoals" placeholder="Things I want to learn or do..."></textarea>
              </label>
              <label>Demotivation
                <textarea id="pfDemotivation" placeholder="This destroys my mood..."></textarea>
              </label>
              <label>Interests
                <textarea id="pfInterests" placeholder="What do you like to connect about?"></textarea>
              </label>
              <label>Interesting fact(s)
                <textarea id="pfFacts" placeholder="Tell us something fun!"></textarea>
              </label>
              <label>Traits (adjectives)
                <textarea id="pfTraits" placeholder="Important to know about me..."></textarea>
              </label>
              <div class="profile-actions" style="grid-column:1 / -1; margin-top:4px;">
                <button id="saveProfileBtn" type="button">Save Profile</button>
                <button id="cancelEditProfileBtn" type="button" style="display:none;">Cancel</button>
                <span class="muted" id="profileMsg"></span>
              </div>
            </form>
          </div>
        </div>

        
        <div class="card" id="classProfilesCard" style="display:none;">
          <div class="row" style="margin-bottom:8px; align-items:flex-end; gap:8px; flex-wrap:wrap;">
            <h2 style="margin:0;">Class Profiles</h2>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              <label for="cpSectionSelect">Section
                <select id="cpSectionSelect" name="cpSectionSelect" aria-label="Profiles section filter"></select>
              </label>
              <label for="cpSearch">Search
                <input type="text" id="cpSearch" name="cpSearch" placeholder="Name or email" aria-label="Search profiles" style="padding:8px 10px; border:1px solid #d0d5dd; border-radius:10px; background:#ffffff; color:#0e0f14;" />
              </label>
            </div>
          </div>
          <div id="classProfilesMsg" class="muted" style="margin:-6px 0 8px 0;"></div>
          <div id="classProfilesGrid" class="profiles-grid"></div>
        </div>

        <!-- Profile View Modal -->
        <div id="profileViewModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="profileViewTitle">
          <div class="modal-dialog">
            <h3 id="profileViewTitle">Profile</h3>
            <div id="profileViewBody" style="display:grid; grid-template-columns: 200px 1fr; gap:12px;">
              <img id="profileViewAvatar" class="avatar" alt="Profile avatar" />
              <div id="profileViewInfo"></div>
            </div>
            <div style="margin-top:10px;">
              <h3 style="margin:0 0 6px; font-size:14px;">Comments</h3>
              <div id="profileCommentsList" style="display:grid; gap:8px;"></div>
              <div style="display:flex; gap:8px; align-items:flex-start; margin-top:6px;">
                <textarea id="profileCommentInput" rows="3" placeholder="Leave a supportive, constructive comment…" style="flex:1; font-size:15px; padding:10px 12px; border:1px solid #d0d5dd; border-radius:10px; background:#fff; color:#0e0f14;"></textarea>
                <button id="profileCommentSaveBtn" type="button">Post</button>
              </div>
              <div class="muted" id="profileCommentMsg" style="margin-top:6px;"></div>
            </div>
            <div class="modal-actions">
              <button id="profileViewCloseBtn" type="button">Close</button>
            </div>
          </div>
        </div>

        <div class="card" id="attendanceRecordCard" style="display:none;">
          <div class="row" style="margin-bottom:8px;">
            <h2 style="margin:0;">Section Attendance (This Week)</h2>
            <div>
              <button id="attWeekPrev">◀ Week</button>
              <button id="attWeekToday">Today</button>
              <button id="attWeekNext">Week ▶</button>
              <button id="attExportCsv">Export CSV</button>
            </div>
          </div>
          <div class="muted" id="attRecordStudent" style="margin-bottom:6px;">Section</div>
          <div class="muted" id="attRecordMonthLabel" style="margin:-4px 0 8px 0;">Week</div>
          <div id="attSectionTableWrap" style="overflow:auto;">
            <table id="attSectionTable" aria-label="Section attendance this week">
              <thead>
                <tr>
                  <th>Student</th>
                  <th id="attCol1">Day 1</th>
                  <th id="attCol2">Day 2</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div id="attChipEmpty" class="muted">No students to show</div>
          <div id="attChipList" class="att-chips" style="display:none;"></div>
        </div>

        <div class="card" id="groupsCard">
          <h2>Groups in Your Section</h2>
          <div class="muted" id="groupEmpty">No groups found</div>
          <div id="groupsList" style="display:grid; gap:10px;"></div>
        </div>

        <div class="card" id="assignmentsCard">
          <h2>Assignments</h2>
          <div style="overflow:auto;">
            <table id="assignmentsTable" aria-label="Assignments status">
              <thead>
                <tr><th>Assignment</th><th>Status</th><th>Updated</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div style="margin-top:12px;">
            <h3 style="margin:0 0 6px; font-size:14px;">Evaluate Peer Reviews You Received</h3>
            <div id="peerEvalList" style="display:grid; gap:10px;"></div>
            <div class="muted" id="peerEvalEmpty">No peer reviews to evaluate yet.</div>
          </div>
        </div>

        <div class="card" id="specsCard">
          <div class="row" style="margin-bottom:8px;">
            <h2 style="margin:0;">Specifications</h2>
            <div id="specsAdmin" style="display:none;">
              <button id="specsAddBtn" style="margin-left:8px;">Add Assignment</button>
            </div>
          </div>
          <div class="muted" id="specsMsg" style="margin:-4px 0 8px 0;"></div>
          <div style="overflow:auto;">
            <table id="specsTable" aria-label="Specifications by assignment">
              <thead>
                <tr>
                  <th style="min-width:220px;">Assignment</th>
                  <th style="min-width:220px;">Exceeds Expectations</th>
                  <th style="min-width:220px;">Meets Expectations</th>
                  <th style="min-width:240px;">Not Yet Meeting Expectations</th>
                  <th id="specsAdminActionsHead" style="min-width:100px;">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="muted" id="specsEmpty">No assignments found.</div>
        </div>

        <!-- Edit Specification Modal -->
        <div id="editSpecModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="editSpecTitle" style="display:none;">
          <div class="modal-dialog">
            <h3 id="editSpecTitle">Edit Specifications</h3>
            <div class="muted" id="editSpecAssignLabel" style="margin:-6px 0 8px 0;"></div>
            <div style="display:grid; gap:8px;">
              <label for="editSpecDocUrl">Directions URL (optional)
                <input type="url" id="editSpecDocUrl" name="editSpecDocUrl" aria-label="Directions URL" placeholder="https://..." />
              </label>
              <label for="editALevel">Exceeds Expectations
                <textarea id="editALevel" name="editALevel" rows="3" aria-label="Exceeds Expectations descriptor"></textarea>
              </label>
              <label for="editBLevel">Meets Expectations
                <textarea id="editBLevel" name="editBLevel" rows="3" aria-label="Meets Expectations descriptor"></textarea>
              </label>
              <label for="editCLevel">Not Yet Meeting Expectations
                <textarea id="editCLevel" name="editCLevel" rows="3" aria-label="Not Yet Meeting Expectations descriptor"></textarea>
              </label>
            </div>
            <div class="modal-actions">
              <button id="editSpecCancelBtn" type="button">Cancel</button>
              <button id="editSpecSaveBtn" type="button">Save</button>
            </div>
          </div>
        </div>

        <!-- Add Assignment Modal -->
        <div id="addAssignModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="addAssignTitle">
          <div class="modal-dialog">
            <h3 id="addAssignTitle">Add Assignment</h3>
            <div style="display:grid; gap:8px;">
              <label for="addAssignTitleInput">Title
                <input type="text" id="addAssignTitleInput" name="addAssignTitle" aria-label="Assignment title" />
              </label>
              <label for="addAssignDocUrlInput">Directions URL (optional)
                <input type="url" id="addAssignDocUrlInput" name="addAssignDocUrl" aria-label="Directions URL" placeholder="https://..." />
              </label>
              <label for="addAssignExceedsLevel">Exceeds Expectations
                <textarea id="addAssignExceedsLevel" name="addAssignExceedsLevel" rows="3" aria-label="Exceeds Expectations descriptor"></textarea>
              </label>
              <label for="addAssignMeetsLevel">Meets Expectations
                <textarea id="addAssignMeetsLevel" name="addAssignMeetsLevel" rows="3" aria-label="Meets Expectations descriptor"></textarea>
              </label>
              <label for="addAssignNotYetLevel">Not Yet Meeting Expectations
                <textarea id="addAssignNotYetLevel" name="addAssignNotYetLevel" rows="3" aria-label="Not Yet Meeting Expectations descriptor"></textarea>
              </label>
            </div>
            <div class="modal-actions">
              <button id="addAssignCancelBtn" type="button">Cancel</button>
              <button id="addAssignSaveBtn" type="button">Save</button>
            </div>
          </div>
        </div>

        <div class="card" id="peerReviewsCard" style="display:none;">
          <h2>Peer Reviews</h2>
          <div style="display:grid; gap:14px;">
            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Submit Your Work</h3>
              <form id="peerSubmitForm">
                <div style="display:grid; gap:8px;">
                  <label for="peerAssignType">Assignment Type
                    <select id="peerAssignType" name="peerAssignType" aria-label="Submission assignment type">
                      <option value="Diagnostic Essay">Diagnostic Essay</option>
                      <option value="Literature Review Draft">Literature Review Draft</option>
                      <option value="Literature Review Final">Literature Review Final</option>
                      <option value="Professional Portfolio">Professional Portfolio</option>
                    </select>
                  </label>
                  <div id="portfolioExtras" style="display:none; gap:8px;">
                    <label for="portfolioCategory">Portfolio Category
                      <select id="portfolioCategory" name="portfolioCategory" aria-label="Portfolio category">
                        <option value="Plan of Action Proposal">Plan of Action Proposal</option>
                        <option value="CV">CV</option>
                        <option value="Cover Letter(s)">Cover Letter(s)</option>
                        <option value="Scholarship Application">Scholarship Application</option>
                        <option value="Exchange Program Application">Exchange Program Application</option>
                        <option value="Internship Application">Internship Application</option>
                        <option value="LinkedIn Profile">LinkedIn Profile</option>
                        <option value="Other">Other</option>
                      </select>
                    </label>
                    <label for="portfolioTitle">Title of Piece (optional)
                      <input type="text" id="portfolioTitle" name="portfolioTitle" placeholder="e.g., Cover Letter for Acme Internship" aria-label="Portfolio piece title" />
                    </label>
                  </div>
                  <label for="peerFile">Upload Document (optional)
                    <input type="file" id="peerFile" name="peerFile" aria-label="Upload document" />
                  </label>
                  <label for="peerUrl">Or Google Docs URL (optional)
                    <input type="url" id="peerUrl" name="peerUrl" placeholder="https://docs.google.com/..." aria-label="Google Docs URL" />
                  </label>
                  <label for="peerText">Or type your reflection (optional)
                    <textarea id="peerText" name="peerText" rows="6" placeholder="Type your reflection..." aria-label="Reflection text"></textarea>
                  </label>
                  <button type="submit">Submit</button>
                  <div class="muted" id="peerSubmitMsg"></div>
                </div>
              </form>
              <div style="margin-top:12px;">
                <h3 style="margin:0 0 6px; font-size:14px;">Your Portfolio Pieces</h3>
                <div id="myPortfolioList" class="kvs"></div>
                <div class="muted" id="myPortfolioEmpty">No portfolio pieces yet.</div>
                <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                  <button id="seedPortfolioBtn" type="button">Add Sample Items</button>
                  <span class="muted" id="seedPortfolioMsg"></span>
                </div>
              </div>
            </section>

            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Feedback You Received</h3>
              <div id="peerReceived" class="kvs"></div>
              <div class="muted" id="peerReceivedEmpty">No feedback yet</div>
              <div class="muted" id="peerReceivedLegend" style="font-size:12px; margin-top:6px;">
                Legend: Left tag = peer’s specs • Right tag = your evaluation
              </div>
            </section>

            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Complete Your Reviews</h3>
              <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px; flex-wrap:wrap;">
                <label for="reviewAssignType">Assignment Type
                  <select id="reviewAssignType" name="reviewAssignType" aria-label="Review assignment type">
                    <option value="Diagnostic Essay">Diagnostic Essay</option>
                    <option value="Literature Review Draft">Literature Review Draft</option>
                    <option value="Literature Review Final">Literature Review Final</option>
                    <option value="Professional Portfolio">Professional Portfolio</option>
                  </select>
                </label>
                <label id="reviewPortfolioWrap" for="reviewPortfolioCategory" style="display:none;">Portfolio Category
                  <select id="reviewPortfolioCategory" name="reviewPortfolioCategory" aria-label="Review portfolio category">
                    <option value="Plan of Action Proposal">Plan of Action Proposal</option>
                    <option value="CV">CV</option>
                    <option value="Cover Letter(s)">Cover Letter(s)</option>
                    <option value="Scholarship Application">Scholarship Application</option>
                    <option value="Exchange Program Application">Exchange Program Application</option>
                    <option value="Internship Application">Internship Application</option>
                    <option value="LinkedIn Profile">LinkedIn Profile</option>
                    <option value="Other">Other</option>
                  </select>
                </label>
                <button id="addReviewFormBtn" type="button">Click to make an additional review</button>
              </div>
              <div id="peerReviewForms" style="display:grid; gap:10px;"></div>
              <div class="muted" id="peerReviewHint">Select a classmate and write your comments and specs evaluation.</div>
            </section>

            <!-- Admin-only Portfolio management -->
            <section id="portfolioAdmin" style="display:none;">
              <h3 style="margin:0 0 6px; font-size:14px;">Portfolio Admin</h3>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">
                <label for="portfolioAdminSectionSelect">Section
                  <select id="portfolioAdminSectionSelect" name="portfolioAdminSectionSelect" aria-label="Portfolio admin section"></select>
                </label>
                <label for="portfolioAdminSearchInput">Search student
                  <input type="text" id="portfolioAdminSearchInput" name="portfolioAdminSearchInput" placeholder="Name or email" aria-label="Search student by name or email" />
                </label>
                <label for="portfolioAdminCategorySelect">Category
                  <select id="portfolioAdminCategorySelect" name="portfolioAdminCategorySelect" aria-label="Portfolio admin category filter">
                    <option value="">All Categories</option>
                    <option value="Plan of Action Proposal">Plan of Action Proposal</option>
                    <option value="CV">CV</option>
                    <option value="Cover Letter(s)">Cover Letter(s)</option>
                    <option value="Scholarship Application">Scholarship Application</option>
                    <option value="Exchange Program Application">Exchange Program Application</option>
                    <option value="Internship Application">Internship Application</option>
                    <option value="LinkedIn Profile">LinkedIn Profile</option>
                    <option value="Other">Other</option>
                  </select>
                </label>
              </div>
              <div class="muted" id="portfolioAdminMsg" style="margin-bottom:6px;"></div>
              <div id="portfolioAdminList" style="display:grid; gap:10px;"></div>
            </section>
          </div>
        </div>

        <div class="card" id="reflectionsCard" style="display:none;">
          <h2>Reflections</h2>
          <div style="display:grid; gap:14px;">
            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Submit Your Reflection</h3>
              <form id="reflSubmitForm">
                <div style="display:grid; gap:8px;">
                  <label for="reflTitle">Reflection Title
                    <select id="reflTitle" name="reflTitle" aria-label="Reflection title">
                      <option value="Reflection 1">Reflection 1</option>
                      <option value="Reflection 2">Reflection 2</option>
                      <option value="Reflection 3">Reflection 3</option>
                      <option value="Reflection 4">Reflection 4</option>
                    </select>
                  </label>
                  <label for="reflText">Type your reflection
                    <textarea id="reflText" name="reflText" rows="6" placeholder="Type your reflection..." aria-label="Reflection text"></textarea>
                  </label>
                  <button type="submit">Submit</button>
                  <div class="muted" id="reflSubmitMsg"></div>
                </div>
              </form>
            </section>

            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Feedback You Received</h3>
              <div id="reflReceived" class="kvs"></div>
              <div class="muted" id="reflReceivedEmpty">No feedback yet</div>
              <div class="muted" id="reflReceivedLegend" style="font-size:12px; margin-top:6px; display:none;">
                Legend: Left tag = peer’s specs • Right tag = your evaluation
              </div>
            </section>

            <section>
              <h3 style="margin:0 0 6px; font-size:14px;">Complete Your Reviews</h3>
              <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px; flex-wrap:wrap;">
                <button id="addReflReviewFormBtn" type="button">Click to make an additional review</button>
              </div>
              <div id="reflReviewForms" style="display:grid; gap:10px;"></div>
              <div class="muted" id="reflReviewHint">Select a classmate and write your comments and specs evaluation.</div>
            </section>
          </div>
        </div>

        <div class="card" id="manageGroupsCard" style="display:none;">
      <div class="mg-head">
            <h2>Manage Groups (Admin)</h2>
            <div style="display:flex; gap:8px; align-items:center;">
              <button id="mgSeedBtn" title="Insert demo students and members">Seed Demo Data</button>
              <button id="mgRandomBtn" title="Randomly assign students in section into groups">Randomize</button>
              <button id="mgNormalizeBtn" title="Delete typo groups and rename sections to 5/6/7">Fix Sections</button>
              <div class="pills" id="mgSections"></div>
            </div>
          </div>
      <div class="muted" id="mgHint" style="margin-bottom:8px;">Six groups of four per section. Drag and drop students into groups.</div>
      <div class="muted" id="mgStatus" style="margin:-4px 0 8px 0;"></div>
          <div class="mg-unassigned">
            <h3 style="margin:0 0 6px; font-size:14px;">Unassigned Students</h3>
            <ul id="mgUnassigned" class="mg-list drop-target"></ul>
          </div>
          <div class="mg-grid" id="mgGrid"></div>
        </div>
      </section>

      <aside class="right">
        

        <div class="card" id="attendanceCard">
          <div class="row" style="margin-bottom:8px;">
            <h2 style="margin:0;">Attendance</h2>
            <div>
              <button id="attPrevMonth">◀</button>
              <button id="attNextMonth">▶</button>
            </div>
          </div>
          <div class="muted" id="attMonthLabel" style="margin:-6px 0 2px 0;">Month</div>
          <div class="muted" id="attClassInfo" style="font-size:12px; margin:0 0 8px 0;"></div>
          <div class="cal-head">
            <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
          </div>
          <div class="calendar" id="attCalendar"></div>
          <div id="attLegend" class="muted" style="margin-top:6px; font-size:12px;">
            Legend: <span class="tag ok">Present</span> <span class="tag warn">Late</span> <span class="tag err">Absent</span> <span class="nc">NC = No Class</span>
          </div>
          <div style="margin-top:10px;">
            <button id="markAttendanceBtn" aria-label="Mark today's attendance">Mark Today</button>
          </div>
          <div class="muted" id="attendanceMsg" style="margin-top:8px;"></div>
          <div id="attendanceAdmin" style="display:none; margin-top:14px;">
            <h3 style="margin:0 0 6px; font-size:14px;">Admin Attendance Editor</h3>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <label for="attAdminSection">Section
                <select id="attAdminSection" name="attAdminSection" aria-label="Attendance admin section"></select>
              </label>
              <label for="attAdminStudent">Student
                <select id="attAdminStudent" name="attAdminStudent" aria-label="Attendance admin student"></select>
              </label>
              <label for="attAdminDate">Date
                <input type="date" id="attAdminDate" name="attAdminDate" aria-label="Attendance admin date" />
              </label>
              <label for="attAdminStatus">Status
                <select id="attAdminStatus" name="attAdminStatus" aria-label="Attendance admin status">
                  <option value="present">Present</option>
                  <option value="late">Late</option>
                  <option value="absent">Absent</option>
                </select>
              </label>
              <button id="attAdminSave">Save</button>
            </div>
            <div class="muted" id="attAdminMsg" style="margin-top:6px;"></div>
          </div>
        </div>
      </aside>
    </main>

    
  <script type="module">
      import { requireAuth, getStudentProfile, signOutAndGo, getSupabase } from './app.js';
      const supabase = getSupabase();
      // Allow overriding peer table names via global config, defaulting to canonical names
      const PEER_REVIEWS_TABLE = (window.PEER_REVIEWS_TABLE || 'peer_reviews');
      const PEER_SUBMISSIONS_TABLE = (window.PEER_SUBMISSIONS_TABLE || 'peer_submissions');
      // Table existence probes (cached)
      let PEER_REVIEWS_EXISTS = true;
      let PEER_SUBMISSIONS_EXISTS = true;
  // Column capability flags (probed lazily)
  let PEER_REVIEWS_HAS_ASSIGNMENT_TYPE = true;
      async function probeTablesOnce() {
        try {
          const { error: prErr } = await supabase.from(PEER_REVIEWS_TABLE).select('*').limit(1);
          if (prErr) PEER_REVIEWS_EXISTS = false;
        } catch { PEER_REVIEWS_EXISTS = false; }
        try {
          const { error: psErr } = await supabase.from(PEER_SUBMISSIONS_TABLE).select('*').limit(1);
          if (psErr) PEER_SUBMISSIONS_EXISTS = false;
        } catch { PEER_SUBMISSIONS_EXISTS = false; }
      }
      // Kick off probes ASAP so initial loads can skip missing tables
      try { probeTablesOnce(); } catch {}

      // Elements
  const greeting = document.getElementById('greeting');
      const details = document.getElementById('details');
      const signOutBtn = document.getElementById('signOutBtn');
      const openDeploysBtn = document.getElementById('openDeploysBtn');
  // Profile elements
  const profileForm = document.getElementById('profileForm');
  const profilePhoto = document.getElementById('profilePhoto');
  const profilePhotoFile = document.getElementById('profilePhotoFile');
  const openCameraBtn = document.getElementById('openCameraBtn');
  const capturePhotoBtn = document.getElementById('capturePhotoBtn');
  const closeCameraBtn = document.getElementById('closeCameraBtn');
  const cameraWrap = document.getElementById('cameraWrap');
  const cameraVideo = document.getElementById('cameraVideo');
  const photoMsg = document.getElementById('photoMsg');
  const profileSummary = document.getElementById('profileSummary');
  const editProfileBtn = document.getElementById('editProfileBtn');
  const cancelEditProfileBtn = document.getElementById('cancelEditProfileBtn');
  const profileEditMedia = document.getElementById('profileEditMedia');
  const pfFullName = document.getElementById('pfFullName');
  const pfPreferName = document.getElementById('pfPreferName');
  const pfHomebase = document.getElementById('pfHomebase');
  const pfPrevEdu = document.getElementById('pfPrevEdu');
  const pfBestTimes = document.getElementById('pfBestTimes');
  const pfFavFoodBooks = document.getElementById('pfFavFoodBooks');
  const pfComms = document.getElementById('pfComms');
  const pfStrong = document.getElementById('pfStrong');
  const pfAdvice = document.getElementById('pfAdvice');
  const pfGoals = document.getElementById('pfGoals');
  const pfDemotivation = document.getElementById('pfDemotivation');
  const pfInterests = document.getElementById('pfInterests');
  const pfFacts = document.getElementById('pfFacts');
  const pfTraits = document.getElementById('pfTraits');
  const saveProfileBtn = document.getElementById('saveProfileBtn');
  const profileMsg = document.getElementById('profileMsg');
  // Generic avatar (used when a student has no avatar). Keep static; do not read current user's image.
  const GENERIC_AVATAR = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 160'%3E%3Crect width='160' height='160' rx='80' fill='%230c1228'/%3E%3Ccircle cx='80' cy='64' r='28' fill='%239aa4b2'/%3E%3Cpath d='M28 136a52 52 0 01104 0' fill='%239aa4b2'/%3E%3C/svg%3E";
      
  const groupsList = document.getElementById('groupsList');
      const groupEmpty = document.getElementById('groupEmpty');
      const assignmentsTableBody = document.querySelector('#assignmentsTable tbody');
      const peerEvalList = document.getElementById('peerEvalList');
  const peerEvalEmpty = document.getElementById('peerEvalEmpty');
      const specsEmpty = document.getElementById('specsEmpty');
      const specsTable = document.getElementById('specsTable');
      const specsMsg = document.getElementById('specsMsg');
      const specsAdmin = document.getElementById('specsAdmin');
  const specsAddBtn = document.getElementById('specsAddBtn');
  // Legacy hooks removed from UI
  const attendanceMsg = document.getElementById('attendanceMsg');
  // Attendance calendar elements
  const attCalendar = document.getElementById('attCalendar');
  const attMonthLabel = document.getElementById('attMonthLabel');
  const attPrevMonth = document.getElementById('attPrevMonth');
  const attNextMonth = document.getElementById('attNextMonth');
      // Current month anchor for the calendar UI
      let attMonth = new Date();
      // Utilities for dates and schedules
      function ymd(d) {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
      }
      // Default weekly schedules for sections; adjust as needed
      const SECTION_SCHEDULES = {
        'Section 5': { days: [1, 4], start: '08:00' }, // Mon, Thu
        'Section 6': { days: [2, 5], start: '08:00' }, // Tue, Fri
        'Section 7': { days: [3, 5], start: '08:00' }  // Wed, Fri
      };
      function isClassDay(date, section) {
        const cfg = SECTION_SCHEDULES[section];
        if (!cfg) return false;
        return cfg.days.includes(date.getDay());
      }
  // Attendance record (middle column)
  const attRecordStudent = document.getElementById('attRecordStudent');
  const attRecordMonthLabel = document.getElementById('attRecordMonthLabel');
  const attChipList = document.getElementById('attChipList');
  const attChipEmpty = document.getElementById('attChipEmpty');
  const attSectionTable = document.getElementById('attSectionTable');
  const attSectionTableWrap = document.getElementById('attSectionTableWrap');
  const attWeekPrev = document.getElementById('attWeekPrev');
  const attWeekToday = document.getElementById('attWeekToday');
  const attWeekNext = document.getElementById('attWeekNext');
  const attExportCsv = document.getElementById('attExportCsv');
  const attendanceAdmin = document.getElementById('attendanceAdmin');
  const attAdminSection = document.getElementById('attAdminSection');
  const attAdminStudent = document.getElementById('attAdminStudent');
  const attAdminDate = document.getElementById('attAdminDate');
  const attAdminStatus = document.getElementById('attAdminStatus');
  const attAdminSave = document.getElementById('attAdminSave');
  const attAdminMsg = document.getElementById('attAdminMsg');
  const mgSections = document.getElementById('mgSections');
  const mgGrid = document.getElementById('mgGrid');
  const mgSeedBtn = document.getElementById('mgSeedBtn');
  const mgRandomBtn = document.getElementById('mgRandomBtn');
  const mgNormalizeBtn = document.getElementById('mgNormalizeBtn');
  const mgStatus = document.getElementById('mgStatus');
  // Peer Reviews elements
  const peerSubmitForm = document.getElementById('peerSubmitForm');
  const peerAssignType = document.getElementById('peerAssignType');
  const peerFile = document.getElementById('peerFile');
  const peerUrl = document.getElementById('peerUrl');
  const peerText = document.getElementById('peerText');
  const peerSubmitMsg = document.getElementById('peerSubmitMsg');
  const portfolioExtras = document.getElementById('portfolioExtras');
  const portfolioCategory = document.getElementById('portfolioCategory');
  const portfolioTitle = document.getElementById('portfolioTitle');
  const myPortfolioList = document.getElementById('myPortfolioList');
  const myPortfolioEmpty = document.getElementById('myPortfolioEmpty');
  const peerReceived = document.getElementById('peerReceived');
  const peerReceivedEmpty = document.getElementById('peerReceivedEmpty');
  const addReviewFormBtn = document.getElementById('addReviewFormBtn');
  const peerReviewForms = document.getElementById('peerReviewForms');
  const reviewAssignType = document.getElementById('reviewAssignType');
  const reviewPortfolioWrap = document.getElementById('reviewPortfolioWrap');
  const reviewPortfolioCategory = document.getElementById('reviewPortfolioCategory');
  // Reflections tab elements
  const reflSubmitForm = document.getElementById('reflSubmitForm');
  const reflTitle = document.getElementById('reflTitle');
  const reflText = document.getElementById('reflText');
  const reflSubmitMsg = document.getElementById('reflSubmitMsg');
  const reflReceived = document.getElementById('reflReceived');
  const reflReceivedEmpty = document.getElementById('reflReceivedEmpty');
  const addReflReviewFormBtn = document.getElementById('addReflReviewFormBtn');
  const reflReviewForms = document.getElementById('reflReviewForms');
  // Portfolio Admin elements
  const portfolioAdmin = document.getElementById('portfolioAdmin');
  const portfolioAdminSectionSelect = document.getElementById('portfolioAdminSectionSelect');
  const portfolioAdminList = document.getElementById('portfolioAdminList');
  const portfolioAdminMsg = document.getElementById('portfolioAdminMsg');
  const portfolioAdminSearchInput = document.getElementById('portfolioAdminSearchInput');
  const portfolioAdminCategorySelect = document.getElementById('portfolioAdminCategorySelect');
  // Portfolio demo seeding elements
  const seedPortfolioBtn = document.getElementById('seedPortfolioBtn');
  const seedPortfolioMsg = document.getElementById('seedPortfolioMsg');
  const studentViewToggleBtn = document.getElementById('studentViewToggleBtn');
  // Class Profiles elements
  const classProfilesCard = document.getElementById('classProfilesCard');
  const classProfilesGrid = document.getElementById('classProfilesGrid');
  const classProfilesMsg = document.getElementById('classProfilesMsg');
  const cpSectionSelect = document.getElementById('cpSectionSelect');
  const cpSearch = document.getElementById('cpSearch');
  const profileViewModal = document.getElementById('profileViewModal');
  const profileViewCloseBtn = document.getElementById('profileViewCloseBtn');
  const profileViewTitle = document.getElementById('profileViewTitle');
  const profileViewAvatar = document.getElementById('profileViewAvatar');
  const profileViewInfo = document.getElementById('profileViewInfo');
  const profileCommentsList = document.getElementById('profileCommentsList');
  const profileCommentInput = document.getElementById('profileCommentInput');
  const profileCommentSaveBtn = document.getElementById('profileCommentSaveBtn');
  const profileCommentMsg = document.getElementById('profileCommentMsg');
  // Keep the initial placeholder avatar to detect when remote signed URLs fail
  // No global placeholder: avatars should be per-student only

      // ---- Anti-paste / anti-automation helpers for reflections & reviews ----
      function attachNoPaste(el, { message = 'Paste is disabled for this field to encourage original writing.' } = {}) {
        if (!el) return;
        // Informational note shown once per element
        try {
          const note = document.createElement('div');
          note.className = 'muted';
          note.style.fontSize = '12px';
          note.style.marginTop = '4px';
          note.textContent = message;
          // Place note right after the field
          el.insertAdjacentElement('afterend', note);
        } catch {}
        const stop = (e) => { e.preventDefault(); e.stopPropagation(); return false; };
        el.addEventListener('paste', stop);
        el.addEventListener('drop', stop);
        el.addEventListener('dragover', stop);
        el.addEventListener('contextmenu', stop);
        // Block keyboard paste shortcuts
        el.addEventListener('keydown', (e) => {
          const k = (e.key || '').toLowerCase();
          if ((e.ctrlKey || e.metaKey) && k === 'v') return stop(e);
          if (e.shiftKey && k === 'insert') return stop(e);
        });
        // Defensive: block programmatic paste-like insertions
        el.addEventListener('beforeinput', (e) => {
          if (e.isComposing) return; // allow IME composition
          const t = e.inputType || '';
          if (t === 'insertFromPaste' || t === 'insertFromDrop' || t === 'insertFromYank') return stop(e);
        });
      }

      function attachAntiAutoType(el, { cpsWindowMs = 1000, maxCharsPerWindow = 40, cooldownMs = 2000 } = {}) {
        if (!el) return;
        const stamps = [];
        let blockUntil = 0;
        const now = () => Date.now();
        el.addEventListener('beforeinput', (e) => {
          if (e.isComposing) return; // don't penalize IME users
          const n = now();
          if (n < blockUntil) { e.preventDefault(); return; }
          // Only consider normal typed characters
          if (e.inputType === 'insertText') {
            stamps.push(n);
            // prune outside window
            while (stamps.length && (n - stamps[0]) > cpsWindowMs) stamps.shift();
            if (stamps.length > maxCharsPerWindow) {
              blockUntil = n + cooldownMs;
              e.preventDefault();
              try {
                // Lightweight feedback
                let tip = el.nextElementSibling;
                if (!tip || !tip.classList.contains('muted')) {
                  tip = document.createElement('div');
                  tip.className = 'muted';
                  tip.style.fontSize = '12px';
                  tip.style.marginTop = '4px';
                  el.insertAdjacentElement('afterend', tip);
                }
                tip.textContent = 'Slow down a bit—rapid automation is blocked.';
              } catch {}
            }
          }
        });
      }

  // Specs table resolver (supports correct and legacy misspelling)
  let SPEC_TABLE_NAME = 'assignment_spec_descriptors';
  let _specTableResolved = false;
  // Specs housekeeping flags
  let _specsGenericsCleaned = false;
  let _specsAutoSeeding = false;
  let SPEC_WRITES_AVAILABLE = true; // set false if schema/RLS prevents writes
  // Column capability flags (probed at runtime for migration safety)
  // Admin automation toggles (default off to avoid console noise on locked schemas)
  const SPECS_AUTO_CLEAN = !!window.SPECS_AUTO_CLEAN; // delete non-canonical rows automatically
  const SPECS_AUTO_SEED = !!window.SPECS_AUTO_SEED;   // insert missing canonical rows automatically
  // Hard kill-switch: require explicit enablement to allow any writes to Specs
  const SPECS_WRITES_ENABLED = window.SPECS_WRITES_ENABLED === true;
    async function resolveSpecTableName() {
        if (_specTableResolved) return SPEC_TABLE_NAME;
        // Probe correct table name without HEAD to avoid 400s in some PostgREST versions
        try {
      const { error } = await supabase.from('assignment_spec_descriptors').select('*').limit(1);
          if (!error) { SPEC_TABLE_NAME = 'assignment_spec_descriptors'; _specTableResolved = true; return SPEC_TABLE_NAME; }
        } catch {}
        // Try legacy misspelling
        try {
      const { error } = await supabase.from('assignment_spec_descirptors').select('*').limit(1);
          if (!error) { SPEC_TABLE_NAME = 'assignment_spec_descirptors'; _specTableResolved = true; return SPEC_TABLE_NAME; }
        } catch {}
        // Default to correct name
        _specTableResolved = true; return SPEC_TABLE_NAME;
      }

      // -------- Specs helpers --------
      function genUuid() {
        if (window.crypto?.randomUUID) return window.crypto.randomUUID();
        // simple fallback v4
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
          const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8; return v.toString(16);
        });
      }
  // Removed getExistingSpecIndex (unused)
      async function safeUpsertSpecs(rows) {
        await resolveSpecTableName();
        const base = rows
          .map(r => {
            // Explicitly create a new object with only the new column names
            const newRow = {
              assignment_id: genUuid(),
              assignment_title: (r.assignment_title ?? r.title ?? r.name),
            };

            // Only include new column names, never the old ones
            if (r.exceeds_expectations !== undefined) {
              newRow.exceeds_expectations = r.exceeds_expectations;
            }
            if (r.meets_expectations !== undefined) {
              newRow.meets_expectations = r.meets_expectations;
            }
            if (r.not_yet_meeting_expectations !== undefined) {
              newRow.not_yet_meeting_expectations = r.not_yet_meeting_expectations;
            }
            if (r.doc_url !== undefined) {
              newRow.doc_url = r.doc_url;
            }

            return newRow;
          })
          .filter(r => r.assignment_title);

        if (!base.length) return true;

        try {
          const { error } = await supabase.from(SPEC_TABLE_NAME).insert(base, { returning: 'minimal' });
          if (error) {
            console.error('Insert error:', error);
            return false;
          }
          return true;
        } catch (e) {
          console.error('Insert exception:', e);
          return false;
        }
      }

      // Safely merge descriptors by assignment_title with robust conflict handling
      async function safeMergeSpecsByTitle(rows) {
        try {
          await resolveSpecTableName();

          // Load existing rows once and map by normalized title
          const { data } = await supabase.from(SPEC_TABLE_NAME).select('*');
          const list = data || [];
          const norm = s => String(s || '').toLowerCase().trim();
          const getTitle = r => (r.assignment_title ?? r.title ?? r.name);
          const byTitle = new Map(list.map(d => [norm(d.assignment_title ?? d.title ?? d.name), d]));

          const payload = [];
          for (const r of rows) {
            const t = String(getTitle(r) || '').trim();
            if (!t) continue;

            const existing = byTitle.get(norm(t));
            if (existing && existing.id) {
              // Update existing record
              const updateData = {
                id: existing.id,
                assignment_id: existing.assignment_id,
                assignment_title: t
              };

              if (r.exceeds_expectations !== undefined) updateData.exceeds_expectations = r.exceeds_expectations;
              if (r.meets_expectations !== undefined) updateData.meets_expectations = r.meets_expectations;
              if (r.not_yet_meeting_expectations !== undefined) updateData.not_yet_meeting_expectations = r.not_yet_meeting_expectations;
              if (r.doc_url !== undefined) updateData.doc_url = r.doc_url;

              payload.push(updateData);
            } else {
              // Insert new record
              const insertData = {
                assignment_id: genUuid(),
                assignment_title: t
              };

              if (r.exceeds_expectations !== undefined) insertData.exceeds_expectations = r.exceeds_expectations;
              if (r.meets_expectations !== undefined) insertData.meets_expectations = r.meets_expectations;
              if (r.not_yet_meeting_expectations !== undefined) insertData.not_yet_meeting_expectations = r.not_yet_meeting_expectations;
              if (r.doc_url !== undefined) insertData.doc_url = r.doc_url;

              payload.push(insertData);
            }
          }

          if (!payload.length) return true;

          // Process updates and inserts separately
          const updates = payload.filter(p => p.id);
          const inserts = payload.filter(p => !p.id);

          // Handle updates
          if (updates.length > 0) {
            const { error } = await supabase.from(SPEC_TABLE_NAME).upsert(updates, {
              onConflict: 'id',
              ignoreDuplicates: false
            });
            if (error) throw error;
          }

          // Handle inserts one by one to avoid conflicts
          for (const record of inserts) {
            try {
              const { error } = await supabase.from(SPEC_TABLE_NAME).insert(record);
              if (error) {
                // If duplicate, try to update instead
                const { data: existing } = await supabase
                  .from(SPEC_TABLE_NAME)
                  .select('id')
                  .eq('assignment_title', record.assignment_title)
                  .limit(1);

                if (existing && existing.length > 0) {
                  const updateRecord = { ...record, id: existing[0].id };
                  delete updateRecord.assignment_id; // Keep existing assignment_id
                  const { error: updateError } = await supabase.from(SPEC_TABLE_NAME).upsert(updateRecord);
                  if (updateError) throw updateError;
                }
              }
            } catch (e) {
              console.error('Error processing record:', record, e);
            }
          }

          return true;
        } catch (e) {
          console.error('Error in safeMergeSpecsByTitle:', e);
          return false;
        }
      }

    // Auth
  const { user } = await requireAuth();
  // Make metadata available early to avoid TDZ issues
  const meta = (user?.user_metadata) || {};
  const appRoles = (user?.app_metadata?.roles) || [];
  const email = (user?.email || '').toLowerCase();
  const allow = Array.isArray(window.ADMIN_EMAILS) ? window.ADMIN_EMAILS.map(e => String(e).toLowerCase()) : [];
  const isAdmin = (['admin','ta'].includes((meta.role || '').toLowerCase()))
    || appRoles.map(String).map(s=>s.toLowerCase()).some(r => r === 'admin' || r === 'ta')
    || allow.includes(email);
  let currentProfile = null;
  // Feature flags (configurable via window):
  const STUDENTS_WRITES_ENABLED = (window.STUDENTS_WRITES_ENABLED === true);
  const PROFILE_FEATURES_ENABLED = (window.PROFILE_FEATURES_ENABLED !== false);
  const CLASS_PROFILES_ENABLED = (window.CLASS_PROFILES_ENABLED !== false);
  const VISIBLE_TABS = new Set(Array.isArray(window.NAV_VISIBLE_TABS) ? window.NAV_VISIBLE_TABS.map(String) : []);
  // Explicitly enable optional tables to avoid 404s from probing when they don't exist
  // Example to enable later: window.ENABLE_TABLES = ['student_profiles','profiles','profile_comments','comments'];
  const OPTIONAL_TABLES_ENABLED = new Set(
    Array.isArray(window.ENABLE_TABLES) ? window.ENABLE_TABLES.map(String)
    : Array.isArray(window.ENABLE_PROFILE_TABLES) ? window.ENABLE_PROFILE_TABLES.map(String)
    : []
  );
  // Sequence token to prevent concurrent duplicate renders
  let attRecordLoadSeq = 0;
  // Ensure a students row exists for the current user (more defensive to avoid 400s on strict schemas)
  async function ensureSelfStudentRow() {
    try {
      if (!user) return;
      if (!STUDENTS_WRITES_ENABLED) return; // avoid 400s if writes are not configured
      // 1) If it already exists, we're done
      try {
        const { data } = await supabase.from('students').select('id').eq('id', user.id).limit(1);
        if (Array.isArray(data) && data.length) return;
      } catch {}
      // 2) Insert minimal row with id only (most schemas accept this)
      let inserted = false;
      try {
        const ins = await supabase.from('students').insert({ id: user.id }, { returning: 'minimal' });
        inserted = !ins.error;
      } catch { /* ignore */ }
      // 3) Best-effort: patch email and full_name separately (skip section to avoid constraint mismatches)
      const meta = (user?.user_metadata) || {};
      const safeName = meta.full_name || (user.email ? user.email.split('@')[0] : '') || null;
      try { await supabase.from('students').update({ email: user.email || null }).eq('id', user.id); } catch {}
      try { if (safeName) await supabase.from('students').update({ full_name: safeName }).eq('id', user.id); } catch {}
      // Note: intentionally do not write section here; some deployments enforce a strict check.
      return inserted;
    } catch { return; }
  }
  // Local overlay for immediate UI reflection of attendance writes
  // Keys are YYYY-MM-DD; values are { status, created_at }
  const attendanceOverlay = new Map();
      if (!user) {
        // redirected by requireAuth
      } else {
  // Prefer full name in greeting if available
  greeting.textContent = `Welcome, ${(user.user_metadata?.full_name) || user.email}`;
        try {
          // Ensure a students row exists for this user (handles magic link confirm path)
          async function ensureProfileExists() {
            // Check if profile exists by id first
            try {
              const { data } = await supabase.from('students').select('id, full_name, section').eq('id', user.id).limit(1);
              if (data && data.length) return data[0];
            } catch {}
            // Build from metadata
            const meta = (user?.user_metadata) || {};
            if (STUDENTS_WRITES_ENABLED) {
              try {
                await ensureSelfStudentRow();
                // Return a minimal profile based on known data; section may be null to avoid constraint issues
                const full_name = meta.full_name || (user.email ? user.email.split('@')[0] : '') || null;
                return { id: user.id, full_name };
              } catch {}
            }
            return null;
          }

          let profile = await getStudentProfile(user);
          if (!profile) {
            await ensureProfileExists();
            profile = await getStudentProfile(user);
          }
          currentProfile = profile || null;
          if (currentProfile) {
            details.textContent = `${currentProfile.full_name || 'Unnamed'} — section ${currentProfile.section || 'N/A'}`;
            // Load profile extras and avatar if present
            try { await hydrateProfileUIFromDbOrLocal(); } catch {}
            // If auth metadata has a better full name, sync it to students (optional)
            try {
              if (STUDENTS_WRITES_ENABLED) {
                const desiredName = meta.full_name || user.user_metadata?.full_name;
                if (desiredName && desiredName !== currentProfile.full_name) {
                  await supabase.from('students').update({ full_name: desiredName }).eq('id', user.id);
                  currentProfile.full_name = desiredName;
                }
              }
            } catch {}
          } else {
            details.innerHTML = `No profile found (RLS or tables may block).`;
          }
        } catch {
          details.textContent = 'Could not load profile (RLS or network).';
        }
      }

      // Gate Admin controls by metadata or optional global ADMIN_EMAILS allowlist
      const manageGroupsBtn = document.getElementById('manageGroupsBtn');
  if (!isAdmin && manageGroupsBtn) {
        manageGroupsBtn.style.display = 'none';
      }
  if (portfolioAdmin) portfolioAdmin.style.display = isAdmin ? '' : 'none';
  if (seedPortfolioBtn) seedPortfolioBtn.style.display = isAdmin ? '' : 'none';
  if (openDeploysBtn) {
    openDeploysBtn.style.display = isAdmin ? '' : 'none';
    openDeploysBtn.addEventListener('click', () => {
      const site = (window.NETLIFY_SITE_NAME || 'polite-concha-38b3bd');
      const url = `https://app.netlify.com/sites/${site}/deploys`;
      try { window.open(url, '_blank', 'noopener,noreferrer'); } catch { location.href = url; }
    });
  }
  if (studentViewToggleBtn) {
    studentViewToggleBtn.style.display = isAdmin ? '' : 'none';
    const syncStudentBtn = () => {
      const on = document.body.classList.contains('student-view');
      studentViewToggleBtn.textContent = on ? 'Exit Student View' : 'Student View';
    };
    syncStudentBtn();
    studentViewToggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('student-view');
      syncStudentBtn();
      // If attendance is currently visible, refresh to apply restricted view
      try {
        const attVisible = document.getElementById('attendanceRecordCard')?.style.display !== 'none' || document.getElementById('attendanceCard')?.style.display !== 'none';
        if (attVisible) {
          loadAttendanceMonth();
          loadSectionAttendanceTable();
        }
      } catch {}
    });
  }

  // Nav buttons: show/hide sections like tabs
  // List of all card element IDs, regardless of feature flags (so we can always hide them all)
  const ALL_CARD_IDS = ['groupsCard','assignmentsCard','specsCard','peerReviewsCard','reflectionsCard','attendanceCard','attendanceRecordCard','profileCard','classProfilesCard','profileViewModal','manageGroupsCard'];
  const sections = {
        groups: ['groupsCard'],
        assignments: ['assignmentsCard'],
  specs: ['specsCard'],
  peerReviews: ['peerReviewsCard'],
  reflections: ['reflectionsCard'],
  attendance: ['attendanceCard','attendanceRecordCard'],
  ...(PROFILE_FEATURES_ENABLED ? { profile: ['profileCard'] } : {}),
  ...(CLASS_PROFILES_ENABLED ? { classProfiles: ['classProfilesCard','profileViewModal'] } : {}),
        manageGroups: ['manageGroupsCard']
      };
      function showSection(key) {
    // Hide all cards first (including disabled ones)
    for (const id of ALL_CARD_IDS) {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        }
        // Show requested
        const ids = sections[key] || [];
        for (const id of ids) {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
        }
        // Active state
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.dataset.target === key));
        if (key === 'peerReviews' && isAdmin) {
          // initialize admin controls once peer tab is visible
          initPortfolioAdmin().catch(()=>{});
        }
      }
      // Hide nav buttons for disabled tabs
      if (!PROFILE_FEATURES_ENABLED) {
        const b = document.querySelector('.nav-btn[data-target="profile"]'); if (b) b.style.display = 'none';
      }
      if (!CLASS_PROFILES_ENABLED) {
        const b = document.querySelector('.nav-btn[data-target="classProfiles"]'); if (b) b.style.display = 'none';
      }
      // Hide any tabs not in the explicit allowlist (if provided)
      if (VISIBLE_TABS.size) {
        document.querySelectorAll('.nav-btn').forEach(b => {
          const key = b.getAttribute('data-target');
          if (!VISIBLE_TABS.has(key)) b.style.display = 'none';
        });
      }

      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const key = btn.dataset.target;
          if (VISIBLE_TABS.size && !VISIBLE_TABS.has(key)) return;
          showSection(key);
          if (key === 'manageGroups') {
            if (!isAdmin) return; // ignore if not admin
            await loadManageGroups();
          } else if (key === 'groups') {
            await loadGroupsTab();
          } else if (key === 'peerReviews') {
            await loadPeerReviews();
          } else if (key === 'reflections') {
            await loadReflections();
          } else if (key === 'attendance') {
            await loadAttendanceMonth();
            await initAttendanceAdmin();
          } else if (key === 'specs') {
            await loadSpecs();
          } else if (key === 'classProfiles') {
            await loadClassProfiles(true);
          }
        });
      });
  // Default selection: prefer 'profile' when visible, otherwise 'attendance', otherwise first visible
  (function(){
    let def = 'attendance';
    if (VISIBLE_TABS.size) {
      if (VISIBLE_TABS.has('profile')) def = 'profile';
      else if (VISIBLE_TABS.has('attendance')) def = 'attendance';
      else def = Array.from(VISIBLE_TABS)[0] || def;
    } else if (PROFILE_FEATURES_ENABLED) {
      def = 'profile';
    }
    showSection(def);
  })();

      // -------- Profile: storage and persistence helpers --------
  const PROFILE_BUCKET = (window.PROFILE_BUCKET || 'profile-photos');
  const PROFILE_BUCKET_CANDIDATES = Array.isArray(window.PROFILE_BUCKETS) && window.PROFILE_BUCKETS.length
    ? window.PROFILE_BUCKETS
    : [PROFILE_BUCKET, 'avatars', 'public', 'peer-submissions'];
      const PROFILE_TABLES = ['student_profiles','profiles','students']; // prefer a dedicated table, fallback
      const _tableExistsCache = new Map();
      async function checkTableExists(table) {
        // If not explicitly enabled, assume it doesn't exist (no probe to avoid 404 noise)
        if (!OPTIONAL_TABLES_ENABLED.has(table)) return false;
        if (_tableExistsCache.has(table)) return _tableExistsCache.get(table);
        try {
          const { error } = await supabase.from(table).select('*').limit(1);
          const ok = !error;
          _tableExistsCache.set(table, ok);
          return ok;
        } catch {
          _tableExistsCache.set(table, false);
          return false;
        }
      }
      function lsKey() { return `profile_${user?.id || 'anon'}`; }
      function dataUrlToBlob(dataUrl) {
        const [head, b64] = dataUrl.split(',');
        const mime = /data:(.*?);base64/.exec(head)?.[1] || 'image/png';
        const bin = atob(b64); const arr = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
        return new Blob([arr], { type: mime });
      }
      async function uploadAvatar(blob) {
        try {
          const path = `${user.id}/avatar_${Date.now()}.jpg`;
          const tried = new Set();
          const tryBuckets = PROFILE_BUCKET_CANDIDATES.filter(Boolean);
          let lastError = null;
          for (const b of tryBuckets) {
            if (tried.has(b)) continue; tried.add(b);
            try {
              const { error } = await supabase.storage.from(b).upload(path, blob, { upsert:false, contentType: blob.type||'image/jpeg' });
              if (!error) return { bucket: b, path };
              lastError = error || lastError;
            } catch (e) { lastError = e || lastError; }
          }
          if (lastError) { try { photoMsg.textContent = `Upload blocked (${lastError.message || 'Storage/RLS'}).`; } catch {} }
          return null;
        } catch { return null; }
      }
      async function getSignedAvatarUrl(path, bucket) {
        try {
          const bkt = bucket || PROFILE_BUCKET;
          const candidates = [bkt, ...PROFILE_BUCKET_CANDIDATES].filter(Boolean);
          const tried = new Set();
          for (const c of candidates) {
            if (tried.has(c)) continue; tried.add(c);
            try { const { data } = await supabase.storage.from(c).createSignedUrl(path, 3600); const url = data?.signedUrl; if (url) return url; } catch {}
          }
        } catch {}
        return null;
      }
      // Signed avatar URL cache (persists across reloads)
      const AVATAR_URL_CACHE = new Map(); // key: path, value: { url, exp }
      (function restoreAvatarCache(){
        try {
          const raw = localStorage.getItem('avatarUrlCache');
          if (!raw) return;
          const obj = JSON.parse(raw);
          for (const [k,v] of Object.entries(obj||{})) {
            if (v && v.url && v.exp && v.exp > Date.now() - 24*60*60*1000) AVATAR_URL_CACHE.set(k, v);
          }
        } catch {}
      })();
      function persistAvatarCache(){
        try {
          const obj = Object.fromEntries(AVATAR_URL_CACHE.entries());
          localStorage.setItem('avatarUrlCache', JSON.stringify(obj));
        } catch {}
      }
      async function getOrCreateSignedAvatarUrl(path, bucket) {
        try {
          const hit = AVATAR_URL_CACHE.get(path);
          if (hit && hit.exp && hit.exp > Date.now() && hit.url) return hit.url;
        } catch {}
        const url = await getSignedAvatarUrl(path, bucket);
        if (url) {
          try { AVATAR_URL_CACHE.set(path, { url, exp: Date.now() + 55 * 60 * 1000 }); persistAvatarCache(); } catch {}
        }
        return url;
      }
      async function setAvatarPreviewFromPath(path, bucket) {
        try { const url = await getSignedAvatarUrl(path, bucket); if (url) { profilePhoto.src = url; return true; } } catch {}
        return false;
      }
      function blobToDataUrl(blob) { return new Promise((resolve) => { try { const r=new FileReader(); r.onload=()=>resolve(r.result); r.readAsDataURL(blob); } catch { resolve(null); } }); }
      async function saveProfileToAnyTable(patch) {
        for (const t of PROFILE_TABLES) {
          try {
            const exists = await checkTableExists(t);
            if (!exists) continue;
            // Update first; if no row exists, insert
            const upd = await supabase.from(t).update(patch).eq('id', user.id);
            if (!upd.error && (upd?.status === 204 || upd?.data || true)) return true;
            const ins = await supabase.from(t).insert({ id: user.id, ...patch });
            if (!ins.error) return true;
          } catch {}
        }
        return false;
      }
      async function loadProfileFromAnyTable() {
        for (const t of PROFILE_TABLES) {
          try {
            const exists = await checkTableExists(t);
            if (!exists) continue;
            const { data } = await supabase.from(t).select('*').eq('id', user.id).limit(1);
            if (Array.isArray(data) && data.length) return { table: t, row: data[0] };
          } catch {}
        }
        return { table: null, row: null };
      }
      function hasAnyProfileContent(obj) {
        if (!obj || typeof obj !== 'object') return false;
        const keys = ['full_name','prefer_name','homebase','previous_education','best_times','fav_food_books','comms','strong_points','advice_topics','goals','demotivation','interests','facts','traits','avatar_path','avatar_bucket','avatar_data_url'];
        return keys.some(k => {
          const v = obj[k];
          return v !== undefined && v !== null && String(v).trim() !== '';
        });
      }
      async function syncLocalProfileToDb() {
        try {
          if (!PROFILE_FEATURES_ENABLED) return false;
          // Only attempt if a dedicated table exists
          const canUse = await checkTableExists('student_profiles') || await checkTableExists('profiles') || await checkTableExists('students');
          if (!canUse) return false;
          const fromLs = JSON.parse(localStorage.getItem(lsKey()) || '{}');
          if (!hasAnyProfileContent(fromLs)) return false;
          const ok = await saveProfileToAnyTable(fromLs);
          if (ok) {
            try { localStorage.setItem(lsKey()+':lastSync', String(Date.now())); } catch {}
          }
          return ok;
        } catch { return false; }
      }
      async function hydrateProfileUIFromDbOrLocal() {
        if (!PROFILE_FEATURES_ENABLED) return;
        // Prefer a merge: use DB values, but fall back to local non-empty values to avoid losing data on reloads
  const { row } = await loadProfileFromAnyTable();
        const fromLs = JSON.parse(localStorage.getItem(lsKey()) || '{}');
        const pick = (a,b) => {
          const av = a; const bv = b;
          const empty = v => v === undefined || v === null || (typeof v === 'string' && v.trim() === '');
          return empty(av) ? bv : av;
        };
        const keys = ['full_name','prefer_name','preferred_name','nickname','homebase','previous_education','best_times','fav_food_books','comms','strong_points','advice_topics','goals','demotivation','interests','facts','traits','avatar_path','avatar_bucket','avatar_data_url','photo_path','avatar'];
        const src = {};
        for (const k of keys) src[k] = pick(row?.[k], fromLs?.[k]);
        pfFullName.value = src.full_name || currentProfile?.full_name || '';
        pfPreferName.value = src.prefer_name || src.preferred_name || src.nickname || '';
        pfHomebase.value = src.homebase || '';
        pfPrevEdu.value = src.previous_education || '';
        pfBestTimes.value = src.best_times || '';
        pfFavFoodBooks.value = src.fav_food_books || '';
        pfComms.value = src.comms || '';
        pfStrong.value = src.strong_points || '';
        pfAdvice.value = src.advice_topics || '';
        pfGoals.value = src.goals || '';
        pfDemotivation.value = src.demotivation || '';
        pfInterests.value = src.interests || '';
        pfFacts.value = src.facts || '';
        pfTraits.value = src.traits || '';
  const avatar = src.avatar_path || src.photo_path || src.avatar;
  const avatarBucket = src.avatar_bucket || null;
  // Show local immediately to avoid flicker, then try remote (progressive enhancement)
  const localDataUrl = src.avatar_data_url || null;
  if (localDataUrl) { try { profilePhoto.src = localDataUrl; } catch {} }
  let remoteSet = false;
  if (avatar) remoteSet = await setAvatarPreviewFromPath(avatar, avatarBucket);
        // If we showed a remote avatar but have no local copy cached yet, cache one for use in Class Profiles
        try {
          if (remoteSet && !localDataUrl && profilePhoto?.src) {
            const resp = await fetch(profilePhoto.src);
            if (resp.ok) {
              const blob = await resp.blob();
              const reader = new FileReader();
              const dataUrl = await new Promise(res => { reader.onload = () => res(reader.result); reader.readAsDataURL(blob); });
              if (dataUrl) {
                const cur = JSON.parse(localStorage.getItem(lsKey())||'{}');
                cur.avatar_data_url = dataUrl;
                // Preserve known path/bucket for future remote loads
                if (avatar) cur.avatar_path = avatar;
                if (avatarBucket) cur.avatar_bucket = avatarBucket;
                localStorage.setItem(lsKey(), JSON.stringify(cur));
              }
            }
          }
        } catch {}
        // Update greeting with preferred name if present
        const prefer = pfPreferName.value.trim();
        if (prefer) greeting.textContent = `Welcome, ${prefer}`;
        // Update summary card using existing renderer (combine student + extras)
        try {
          const student = currentProfile || { full_name: pfFullName.value.trim(), email: (user?.email||'') };
          profileSummary.innerHTML = renderProfileInfoHtml(student, src);
        } catch {}
        // Keep DB and local in sync bi-directionally
        if (!row && hasAnyProfileContent(fromLs)) {
          try { await syncLocalProfileToDb(); } catch {}
        } else if (row && !hasAnyProfileContent(fromLs)) {
          try { localStorage.setItem(lsKey(), JSON.stringify(row)); localStorage.setItem(lsKey()+':lastGood', JSON.stringify(row)); } catch {}
        }
        // Enter view mode if we have at least a name or any content saved
        try {
          const hasContent = Boolean(pfFullName.value.trim() || pfPreferName.value.trim() || Object.values(src).some(v=>v));
          setProfileEditMode(!hasContent);
        } catch {}
      }
      // Also retry syncing local profile to DB when the app comes back online
      window.addEventListener('online', () => { try { syncLocalProfileToDb(); } catch {} });

      function setProfileEditMode(on) {
        if (!PROFILE_FEATURES_ENABLED) return;
        const show = (el, yes) => { if (el) el.style.display = yes ? '' : 'none'; };
        show(profileForm, on);
        show(profileEditMedia, on);
        show(saveProfileBtn, on);
        show(cancelEditProfileBtn, on);
        show(editProfileBtn, !on);
        // Summary always visible, but becomes primary content in view mode
        try {
          const card = document.getElementById('profileCard');
          if (card) card.classList.toggle('view-mode', !on);
        } catch {}
      }

      editProfileBtn?.addEventListener('click', () => setProfileEditMode(true));
      cancelEditProfileBtn?.addEventListener('click', () => { setProfileEditMode(false); try { hydrateProfileUIFromDbOrLocal(); } catch {} });

      // Camera/open handlers
      let mediaStream = null;
  if (PROFILE_FEATURES_ENABLED) openCameraBtn?.addEventListener('click', async () => {
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
          cameraVideo.srcObject = mediaStream; await cameraVideo.play();
          cameraWrap.style.display = 'flex'; photoMsg.textContent = '';
        } catch { photoMsg.textContent = 'Camera not available or permission denied.'; }
      });
  if (PROFILE_FEATURES_ENABLED) closeCameraBtn?.addEventListener('click', () => {
        try { cameraVideo.pause(); } catch {}
        try { mediaStream?.getTracks()?.forEach(t=>t.stop()); } catch {}
        cameraWrap.style.display = 'none';
      });
  if (PROFILE_FEATURES_ENABLED) capturePhotoBtn?.addEventListener('click', async () => {
        try {
          const canvas = document.createElement('canvas');
          const w = 720; const h = Math.round((cameraVideo.videoHeight || 720) * (w / (cameraVideo.videoWidth || 720)));
          canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d');
          ctx.drawImage(cameraVideo, 0, 0, w, h);
      const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
      // Let user crop before upload
      const cropped = await openCropper(dataUrlToBlob(dataUrl));
      const blob = cropped || dataUrlToBlob(dataUrl);
          profilePhoto.src = URL.createObjectURL(blob); // preview immediately
          try { window.MY_LOCAL_AVATAR_DATA_URL = await blobToDataUrl(blob); } catch {}
          photoMsg.textContent = 'Uploading…';
          const uploaded = await uploadAvatar(blob);
          if (uploaded && uploaded.path) {
            await saveProfileToAnyTable({ avatar_path: uploaded.path, avatar_bucket: uploaded.bucket });
            try {
              const dataUrl = await blobToDataUrl(blob);
              const cur = JSON.parse(localStorage.getItem(lsKey())||'{}');
              cur.avatar_path = uploaded.path; cur.avatar_bucket = uploaded.bucket; if (dataUrl) cur.avatar_data_url = dataUrl;
              localStorage.setItem(lsKey(), JSON.stringify(cur));
              if (dataUrl) window.MY_LOCAL_AVATAR_DATA_URL = dataUrl;
            } catch {}
            await setAvatarPreviewFromPath(uploaded.path, uploaded.bucket); photoMsg.textContent = 'Saved photo.'; }
          else {
            try {
              const dataUrl = await blobToDataUrl(blob);
              const cur = JSON.parse(localStorage.getItem(lsKey())||'{}');
              if (dataUrl) { cur.avatar_data_url = dataUrl; localStorage.setItem(lsKey(), JSON.stringify(cur)); }
              if (dataUrl) window.MY_LOCAL_AVATAR_DATA_URL = dataUrl;
            } catch {}
            photoMsg.textContent = 'Upload blocked. Saved locally only.';
          }
          // Refresh class profiles if the tab is visible
          try {
            const isVisible = document.getElementById('classProfilesCard')?.style.display !== 'none';
            if (isVisible) await loadClassProfiles(false);
          } catch {}
        } catch { photoMsg.textContent = 'Capture failed.'; }
      });
  if (PROFILE_FEATURES_ENABLED) profilePhotoFile?.addEventListener('change', async () => {
        const f = profilePhotoFile.files?.[0]; if (!f) return;
        try {
      // Let user crop before upload
      const cropped = await openCropper(f);
      const toUpload = cropped || f;
      profilePhoto.src = URL.createObjectURL(toUpload);
      try { window.MY_LOCAL_AVATAR_DATA_URL = await blobToDataUrl(toUpload); } catch {}
          photoMsg.textContent = 'Uploading…';
          const uploaded = await uploadAvatar(toUpload);
          if (uploaded && uploaded.path) {
            await saveProfileToAnyTable({ avatar_path: uploaded.path, avatar_bucket: uploaded.bucket });
            try {
              const dataUrl = await blobToDataUrl(toUpload);
              const cur = JSON.parse(localStorage.getItem(lsKey())||'{}');
              cur.avatar_path = uploaded.path; cur.avatar_bucket = uploaded.bucket; if (dataUrl) cur.avatar_data_url = dataUrl;
              localStorage.setItem(lsKey(), JSON.stringify(cur));
              if (dataUrl) window.MY_LOCAL_AVATAR_DATA_URL = dataUrl;
            } catch {}
            await setAvatarPreviewFromPath(uploaded.path, uploaded.bucket); photoMsg.textContent = 'Saved photo.'; }
          else {
            try {
              const dataUrl = await blobToDataUrl(toUpload);
              const cur = JSON.parse(localStorage.getItem(lsKey())||'{}');
              if (dataUrl) { cur.avatar_data_url = dataUrl; localStorage.setItem(lsKey(), JSON.stringify(cur)); }
              if (dataUrl) window.MY_LOCAL_AVATAR_DATA_URL = dataUrl;
            } catch {}
            photoMsg.textContent = 'Upload blocked. Saved locally only.';
          }
      // Refresh class profiles if the tab is visible
      try {
        const isVisible = document.getElementById('classProfilesCard')?.style.display !== 'none';
        if (isVisible) await loadClassProfiles(false);
      } catch {}
        } catch { photoMsg.textContent = 'Upload failed.'; }
      });

      // Save profile
  if (PROFILE_FEATURES_ENABLED) saveProfileBtn?.addEventListener('click', async () => {
        const patch = {
          full_name: pfFullName.value.trim() || null,
          prefer_name: pfPreferName.value.trim() || null,
          homebase: pfHomebase.value.trim() || null,
          previous_education: pfPrevEdu.value.trim() || null,
          best_times: pfBestTimes.value.trim() || null,
          fav_food_books: pfFavFoodBooks.value.trim() || null,
          comms: pfComms.value.trim() || null,
          strong_points: pfStrong.value.trim() || null,
          advice_topics: pfAdvice.value.trim() || null,
          goals: pfGoals.value.trim() || null,
          demotivation: pfDemotivation.value.trim() || null,
          interests: pfInterests.value.trim() || null,
          facts: pfFacts.value.trim() || null,
          traits: pfTraits.value.trim() || null
        };
        profileMsg.textContent = 'Saving…';
        // Merge with existing local values so blanks don’t erase prior data
        try {
          const prev = JSON.parse(localStorage.getItem(lsKey())||'{}');
          const merged = { ...prev };
          for (const [k,v] of Object.entries(patch)) {
            const empty = v === null || (typeof v === 'string' && v.trim() === '');
            merged[k] = empty ? prev[k] : v;
          }
          localStorage.setItem(lsKey(), JSON.stringify(merged));
          // Keep a last-good snapshot for safety
          localStorage.setItem(lsKey()+':lastGood', JSON.stringify(merged));
        } catch {}
        let ok = await saveProfileToAnyTable(patch);
        if (!ok && STUDENTS_WRITES_ENABLED) {
          // Try updating students table minimal fields
          try { await supabase.from('students').update({ full_name: patch.full_name || currentProfile?.full_name || null }).eq('id', user.id); ok = true; } catch {}
        }
        // Update greeting if preferred name set
        const prefer = pfPreferName.value.trim();
        if (prefer) greeting.textContent = `Welcome, ${prefer}`;
        profileMsg.textContent = ok ? 'Saved.' : 'Saved locally (DB not available).';
        // Refresh summary card with latest values (prefer saved patch merged with any existing src)
        try {
          const fromLs = JSON.parse(localStorage.getItem(lsKey()) || '{}');
          const src = { ...fromLs, ...patch };
          const student = currentProfile || { full_name: patch.full_name || pfFullName.value.trim(), email: (user?.email||'') };
          profileSummary.innerHTML = renderProfileInfoHtml(student, src);
        } catch {}
  // Switch to view mode after save for readability
  setProfileEditMode(false);
      });

      // Seed sample portfolio rows for current user (admin-only)
      if (seedPortfolioBtn) {
        seedPortfolioBtn.addEventListener('click', async () => {
          if (!user?.id) return;
          seedPortfolioMsg.textContent = 'Seeding…';
          try {
            if (!PEER_SUBMISSIONS_EXISTS) throw new Error('portfolio table missing');
            const rows = [
              { student_id: user.id, assignment_type: 'Professional Portfolio', category: 'CV', title: 'CV v1', text: 'Education\nExperience\nSkills', url: null },
              { student_id: user.id, assignment_type: 'Professional Portfolio', category: 'Cover Letter(s)', title: 'Cover Letter for Acme Internship', text: null, url: 'https://example.com/cover-letter' },
              { student_id: user.id, assignment_type: 'Professional Portfolio', category: 'LinkedIn Profile', title: 'LinkedIn Profile', text: null, url: 'https://www.linkedin.com/in/example' }
            ];
            const { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).insert(rows, { returning: 'minimal' });
            if (error) throw error;
            seedPortfolioMsg.textContent = 'Added sample items.';
            try { await loadMyPortfolio(); } catch {}
            try { if (isAdmin) await loadPortfolioAdmin(true); } catch {}
          } catch {
            seedPortfolioMsg.textContent = 'Seed failed (RLS/tables).';
          }
        });
      }

      // Data loaders (best-effort; tolerate missing tables/RLS)
      // Anchor date for weekly table (any date within the week). Defaults to today.
      let attWeekAnchor = new Date();
      async function loadAttendanceRecord() {
        await loadSectionAttendanceTable();
      }
      // Compute the week range given an anchor and return the two class days for section
      function getWeeksTwoClassDays(section, anchorDate) {
        const cfg = SECTION_SCHEDULES[section];
        if (!cfg) return [];
        const now = anchorDate ? new Date(anchorDate) : new Date();
        // Get Monday of this week (Sun=0 -> Monday=1)
        const day = now.getDay();
        const monday = new Date(now);
        const diffToMon = (day === 0 ? -6 : 1 - day);
        monday.setDate(now.getDate() + diffToMon);
        // Build dates for Mon..Sun
        const week = Array.from({length:7}, (_,i)=> new Date(monday.getFullYear(), monday.getMonth(), monday.getDate()+i));
        // Pick two matching days from schedule (1=Mon..4=Thu..)
        const picks = [];
        for (const d of week) if (cfg.days.includes(d.getDay())) picks.push(d);
        return picks.slice(0,2);
      }

      function statusToShort(status) {
        if (status === 'present') return 'P';
        if (status === 'late') return 'L';
        if (status === 'absent') return 'A';
        return '—';
      }

      async function loadSectionAttendanceTable(forceSection) {
        if (!currentProfile) return;
        const section = forceSection || currentProfile.section;
        if (!section) return;
        const studentViewOn = document.body.classList.contains('student-view');
        const restricted = (!isAdmin) || studentViewOn; // students or Student View see only self
        // Header
        const days = getWeeksTwoClassDays(section, attWeekAnchor);
        const [d1, d2] = [days[0], days[1]];
        const col1 = document.getElementById('attCol1');
        const col2 = document.getElementById('attCol2');
        if (col1) col1.textContent = d1 ? d1.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' }) : 'Day 1';
        if (col2) col2.textContent = d2 ? d2.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' }) : 'Day 2';
        // Adjust subtitle to indicate whose view
        if (attRecordStudent) {
          if (restricted) {
            const who = (currentProfile?.full_name || user?.email || 'You');
            attRecordStudent.textContent = `${who} — ${section}`;
          } else {
            attRecordStudent.textContent = `${section}`;
          }
        }
        // Toggle CSV export button visibility based on mode
        if (attExportCsv) attExportCsv.style.display = restricted ? 'none' : '';
        // Adjust heading text
        try {
          const card = document.getElementById('attendanceRecordCard');
          const h2 = card?.querySelector('h2');
          if (h2) h2.textContent = restricted ? 'Your Attendance (This Week)' : 'Section Attendance (This Week)';
        } catch {}
        if (attRecordMonthLabel) {
          // Show week range Mon..Sun
          const shown = d1 || days[0] || new Date(attWeekAnchor);
          const day = shown.getDay();
          const monday = new Date(shown);
          const diffToMon = (day === 0 ? -6 : 1 - day);
          monday.setDate(shown.getDate() + diffToMon);
          const sunday = new Date(monday); sunday.setDate(monday.getDate()+6);
          attRecordMonthLabel.textContent = `${monday.toLocaleDateString()} – ${sunday.toLocaleDateString()}`;
        }

        // Load students for table
        let studs = [];
        if (restricted) {
          // Only the current user
          studs = [{ id: user.id, full_name: currentProfile?.full_name || '', email: user?.email || '' }];
        } else {
          try {
            const { data } = await supabase.from('students').select('id, full_name, email').eq('section', section).order('full_name');
            studs = data || [];
          } catch {}
        }
        // Dedupe by email to avoid duplicates like "jon.n" vs full name for same person
        const byEmail = new Map();
        for (const s of studs) {
          const key = (s.email || '').toLowerCase();
          if (!key) { byEmail.set(s.id, s); continue; }
          if (!byEmail.has(key)) { byEmail.set(key, s); continue; }
          const existing = byEmail.get(key);
          const score = (x) => {
            const n = (x.full_name || '').trim();
            let sc = n.length;
            if (n.includes(' ')) sc += 5; // prefer full names with a space
            return sc;
          };
          byEmail.set(key, score(s) >= score(existing) ? s : existing);
        }
        studs = Array.from(byEmail.values());
        const tbody = attSectionTable?.querySelector('tbody');
        if (!tbody) return;
        tbody.innerHTML = '';
        if (!studs.length) { attChipEmpty.style.display = ''; return; }
        attChipEmpty.style.display = 'none';

        // Build map of attendance for two days
        const needDates = [d1, d2].filter(Boolean).map(d => ymd(d));
        let mapByStudent = new Map();
        if (needDates.length) {
          try {
            const ids = studs.map(s => s.id);
            const { data } = await supabase
              .from('attendance')
              .select('student_id,date,status,created_at')
              .in('student_id', ids)
              .in('date', needDates);
            for (const r of (data||[])) {
              const m = mapByStudent.get(r.student_id) || new Map();
              m.set(r.date, { status: r.status, created_at: r.created_at });
              mapByStudent.set(r.student_id, m);
            }
          } catch {}
        }
        // Apply local overlay for the two dates
        for (const k of Array.from(attendanceOverlay.keys())) {
          if (needDates.includes(k)) {
            // Overlay only for current user
            const m = mapByStudent.get(user.id) || new Map();
            const v = attendanceOverlay.get(k);
            m.set(k, { status: v.status, created_at: v.created_at });
            mapByStudent.set(user.id, m);
          }
        }
        // Render rows
        for (const s of studs) {
          const tr = document.createElement('tr');
          const name = s.full_name || s.email || s.id;
          const tdName = document.createElement('td');
          tdName.textContent = name;
          tr.appendChild(tdName);
          for (const d of [d1, d2]) {
            const td = document.createElement('td');
            if (d) {
              const k = ymd(d);
              const rec = mapByStudent.get(s.id)?.get(k);
              const status = rec?.status || (d > new Date() ? '—' : 'absent');
              const cls = status === 'absent' ? 'err' : status === 'late' ? 'warn' : status === 'present' ? 'ok' : '';
              td.innerHTML = `<span class="tag ${cls}">${statusToShort(status)}</span>`;
              if (rec?.created_at) td.title = `Recorded: ${new Date(rec.created_at).toLocaleString()}`;
              if (d > new Date()) td.style.opacity = .6;
            } else {
              td.textContent = '—';
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
      }

      // Week navigation and CSV export
      function shiftWeek(offset) {
        const d = new Date(attWeekAnchor);
        d.setDate(d.getDate() + offset * 7);
        attWeekAnchor = d;
      }
      attWeekPrev?.addEventListener('click', async () => { shiftWeek(-1); await loadSectionAttendanceTable(); });
  attWeekToday?.addEventListener('click', async () => { attWeekAnchor = new Date(); await loadSectionAttendanceTable(attAdminSection?.value); });
      attWeekNext?.addEventListener('click', async () => { shiftWeek(1); await loadSectionAttendanceTable(); });

      attExportCsv?.addEventListener('click', async () => {
        const section = attAdminSection?.value || currentProfile?.section;
        if (!section) return;
        const days = getWeeksTwoClassDays(section, attWeekAnchor);
        const [d1, d2] = [days[0], days[1]];
        const needDates = [d1, d2].filter(Boolean).map(d => ymd(d));
        let studs = [];
        try { const { data } = await supabase.from('students').select('id, full_name, email').eq('section', section).order('full_name'); studs = data || []; } catch {}
        // dedupe by email
        const byEmail = new Map();
        for (const s of studs) {
          const key = (s.email || '').toLowerCase();
          if (!byEmail.has(key)) byEmail.set(key, s);
        }
        studs = Array.from(byEmail.values());
        let mapByStudent = new Map();
        if (needDates.length) {
          try {
            const ids = studs.map(s => s.id);
            const { data } = await supabase.from('attendance').select('student_id,date,status').in('student_id', ids).in('date', needDates);
            for (const r of (data||[])) {
              const m = mapByStudent.get(r.student_id) || new Map(); m.set(r.date, r.status); mapByStudent.set(r.student_id, m);
            }
          } catch {}
        }
        const rows = [];
        const header = ['Student','Email', d1? d1.toLocaleDateString(): 'Day 1', d2? d2.toLocaleDateString(): 'Day 2'];
        rows.push(header);
        for (const s of studs) {
          const name = s.full_name || s.email || s.id;
          const v1 = d1 ? (mapByStudent.get(s.id)?.get(ymd(d1)) || '') : '';
          const v2 = d2 ? (mapByStudent.get(s.id)?.get(ymd(d2)) || '') : '';
          rows.push([name, s.email || '', v1, v2]);
        }
        const csv = rows.map(r => r.map(x => {
          const v = (x == null ? '' : String(x));
          return /[",\n]/.test(v) ? '"' + v.replace(/"/g,'""') + '"' : v;
        }).join(','))
        .join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `attendance_${section.replace(/\s+/g,'_')}_${new Date(attWeekAnchor).toISOString().slice(0,10)}.csv`;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
      });

      function getDemoStudents() {
        return [
          { full_name: 'Ada Lovelace', email: 'ada@example.com', section: 'Section 5' },
          { full_name: 'Alan Turing', email: 'alan@example.com', section: 'Section 5' },
          { full_name: 'Grace Hopper', email: 'grace@example.com', section: 'Section 5' },
          { full_name: 'Katherine Johnson', email: 'katherine@example.com', section: 'Section 5' },
          { full_name: 'Barbara Liskov', email: 'barbara@example.com', section: 'Section 6' },
          { full_name: 'Donald Knuth', email: 'donald@example.com', section: 'Section 6' },
          { full_name: 'Linus Torvalds', email: 'linus@example.com', section: 'Section 6' },
          { full_name: 'Margaret Hamilton', email: 'margaret@example.com', section: 'Section 6' },
          { full_name: 'Edsger Dijkstra', email: 'edsger@example.com', section: 'Section 7' },
          { full_name: 'Tim Berners-Lee', email: 'tim@example.com', section: 'Section 7' },
          { full_name: 'Hedy Lamarr', email: 'hedy@example.com', section: 'Section 7' },
          { full_name: 'Claude Shannon', email: 'claude@example.com', section: 'Section 7' },
        ];
      }

      async function ensureDemoStudentsPresent({ force = false } = {}) {
        // If not forcing, only seed when table is empty
        if (!force) {
          try {
            const { count } = await supabase.from('students').select('*', { count: 'exact', head: true });
            if (typeof count === 'number' && count > 0) return 0;
          } catch { return 0; }
        }
        const demo = getDemoStudents();
        const emails = demo.map(d => d.email);
        let existing = new Set();
        try {
          const { data } = await supabase.from('students').select('email').in('email', emails);
          (data || []).forEach(r => r?.email && existing.add(r.email));
        } catch {}
        const missing = demo.filter(d => !existing.has(d.email));
        if (!missing.length) return 0;
        let inserted = 0;
        try {
          const { error } = await supabase.from('students').insert(missing);
          if (!error) inserted = missing.length;
        } catch {}
        if (inserted === 0) {
          // Retry with explicit ids for schemas without default uuid
          try {
            const makeId = () => (globalThis.crypto?.randomUUID ? crypto.randomUUID() : `demo-${Math.random().toString(36).slice(2)}-${Date.now()}`);
            const withIds = missing.map(d => ({ id: makeId(), ...d }));
            const { error } = await supabase.from('students').insert(withIds);
            if (!error) inserted = withIds.length;
          } catch {}
        }
        return inserted;
      }

      // ---------- Class Profiles ----------
      const PINNED_EXAMPLE_EMAIL = 'jon.n@vinuni.edu.vn';
      let _profilesCache = { studs: [], extras: new Map() };
      async function loadClassProfiles(resetFilters = false) {
        classProfilesGrid.innerHTML = ''; classProfilesMsg.textContent = '';
        // Populate sections
        const secs = await fetchSections();
        // Also include the current user's section if it's not in the fixed list
        try {
          if (currentProfile?.section && !secs.includes(currentProfile.section)) {
            secs.push(currentProfile.section);
          }
        } catch {}
        if (resetFilters) {
          cpSectionSelect.innerHTML = '';
          for (const s of secs) { const o=document.createElement('option'); o.value=s; o.textContent=s; cpSectionSelect.appendChild(o); }
          const preferred = currentProfile?.section && secs.includes(currentProfile.section) ? currentProfile.section : secs[0];
          cpSectionSelect.value = preferred;
        }
        cpSectionSelect.onchange = () => loadClassProfiles(false);
        cpSearch.oninput = () => loadClassProfiles(false);
        // Load students in section
        let studs = [];
        try {
          const { data } = await supabase.from('students').select('id, full_name, email, section').eq('section', cpSectionSelect.value).order('full_name');
          studs = data || [];
        } catch {}
        // Ensure the current user appears in their own section even if they don't have a students row
        try {
          if (user?.id && currentProfile?.section && currentProfile.section === cpSectionSelect.value) {
            const present = studs.some(s => s.id === user.id || ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()));
            if (!present) {
              studs.unshift({ id: user.id, full_name: currentProfile?.full_name || (user.email||'').split('@')[0] || user.email || 'Me', email: user.email, section: cpSectionSelect.value });
            }
          }
        } catch {}
        // Optionally include pinned example profile across all sections (if not already present)
        try {
          const found = studs.some(s => (s.email||'').toLowerCase() === PINNED_EXAMPLE_EMAIL);
          if (!found) {
            const { data: ex } = await supabase.from('students').select('id, full_name, email, section').eq('email', PINNED_EXAMPLE_EMAIL).limit(1);
            if (ex && ex.length) studs.unshift(ex[0]);
          }
        } catch {}
        // Apply search
        const q = (cpSearch.value||'').trim().toLowerCase();
        if (q) studs = studs.filter(s => (s.full_name||'').toLowerCase().includes(q) || (s.email||'').toLowerCase().includes(q));
        if (!studs.length) { classProfilesMsg.textContent = 'No profiles to show.'; return; }
        // Map id -> extras (profile fields & avatar)
        const ids = studs.map(s => s.id);
        let rows = [];
        // Try dedicated table first if it exists
        try {
          if (await checkTableExists('student_profiles')) {
            const { data } = await supabase.from('student_profiles').select('*').in('id', ids);
            rows = data || [];
          }
        } catch {}
        if (!rows.length) {
          try {
            if (await checkTableExists('profiles')) {
              const { data } = await supabase.from('profiles').select('*').in('id', ids);
              rows = data || [];
            }
          } catch {}
        }
        // cache
        const extraById = new Map(rows.map(r => [r.id, r]));
        // If current user has local profile data, merge it onto any existing row so avatar/info show up immediately
        try {
          if (user?.id) {
            const fromLs = JSON.parse(localStorage.getItem(lsKey()) || '{}');
            if (hasAnyProfileContent(fromLs)) {
              // Merge onto the auth user's id
              const prev = extraById.get(user.id) || {};
              extraById.set(user.id, { ...prev, ...fromLs });
              // Also merge onto any student in the grid with the same email (handles mismatched IDs)
              for (const s of studs) {
                if ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()) {
                  const p2 = extraById.get(s.id) || {};
                  extraById.set(s.id, { ...p2, ...fromLs });
                }
              }
            }
          }
        } catch {}
        // render cards
        for (const s of studs) {
          const card = document.createElement('div'); card.className = 'profile-card';
          const small = document.createElement('img'); small.className = 'profile-sm'; small.alt = 'Avatar'; small.setAttribute('loading','lazy');
          // avatar
          const extra = extraById.get(s.id) || {};
          const path = extra.avatar_path || extra.photo_path || extra.avatar;
          const bkt = extra.avatar_bucket || null;
          // Prefer locally saved data URL for the current user (by id or email) to ensure the photo shows even if Storage is blocked
          let localData = extra.avatar_data_url || null;
          if (!localData && (s.id === user.id || ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()))) {
            try { const cur = JSON.parse(localStorage.getItem(lsKey())||'{}'); if (cur.avatar_data_url) localData = cur.avatar_data_url; } catch {}
          }
          // Start with local image if available (instant display)
          if (localData) {
            try { small.src = localData; } catch {}
          }
          // Also consider a session-scoped global (set on upload) for the current user
          if ((!small.src || small.src === window.location.href || small.src === '') && (s.id === user.id || ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()))) {
            try { if (window.MY_LOCAL_AVATAR_DATA_URL) small.src = window.MY_LOCAL_AVATAR_DATA_URL; } catch {}
          }
          // Try remote; if it fails to load, fall back to local or generic
      if (path) {
            try {
        const url = await getOrCreateSignedAvatarUrl(path, bkt);
              if (url) {
                small.onerror = () => {
      if (localData) small.src = localData; else if (window.MY_LOCAL_AVATAR_DATA_URL && (s.id === user.id || ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()))) small.src = window.MY_LOCAL_AVATAR_DATA_URL; else small.src = GENERIC_AVATAR;
                };
                small.src = url;
              }
            } catch {}
          }
          // If still no src, final fallback
          if (!small.src || small.src === window.location.href || small.src === '') {
            if (localData) small.src = localData; else if (window.MY_LOCAL_AVATAR_DATA_URL && (s.id === user.id || ((s.email||'').toLowerCase() === (user.email||'').toLowerCase()))) small.src = window.MY_LOCAL_AVATAR_DATA_URL; else small.src = GENERIC_AVATAR;
          }

          // Meta below avatar
          const meta = document.createElement('div'); meta.className = 'meta';
          const name = document.createElement('div'); name.className = 'profile-name'; name.textContent = extra.prefer_name || extra.preferred_name || s.full_name || s.email || 'Student';
          const sec = document.createElement('div'); sec.className = 'profile-section'; sec.textContent = s.section || '';
          const lines = document.createElement('div'); lines.className = 'lines';
          const preview = [
            extra.homebase ? `Homebase: ${extra.homebase}` : '',
            extra.previous_education ? `Previous: ${extra.previous_education}` : '',
            extra.best_times ? `Best times: ${extra.best_times}` : '',
            extra.fav_food_books ? `Favorites: ${extra.fav_food_books}` : '',
            extra.interests ? `Interests: ${extra.interests}` : ''
          ].filter(Boolean).join('\n');
          lines.textContent = preview || '';
          const actions = document.createElement('div'); actions.className = 'actions';
          const more = document.createElement('button'); more.type = 'button'; more.className = 'view-more'; more.textContent = 'View more';
          more.addEventListener('click', (e) => { e.stopPropagation(); openProfileModal(s.id, s.full_name || s.email || 'Profile', extra); });

          actions.appendChild(more);
          meta.appendChild(name); meta.appendChild(sec); meta.appendChild(lines); meta.appendChild(actions);
          card.appendChild(small); card.appendChild(meta);
          card.addEventListener('click', () => openProfileModal(s.id, s.full_name || s.email || 'Profile', extra));
          classProfilesGrid.appendChild(card);
        }
      }

      function renderProfileInfoHtml(s, extra) {
        const prefer = extra?.prefer_name || extra?.preferred_name;
        const lines = [
          `<div><strong>${prefer ? prefer + ' (' + (s.full_name||'') + ')' : (s.full_name||'')}</strong><br/><span class="muted">${s.email||''}</span></div>`,
          extra?.homebase ? `<div><strong>Homebase:</strong> ${extra.homebase}</div>` : '',
          extra?.previous_education ? `<div><strong>Previous Education:</strong> ${extra.previous_education}</div>` : '',
          extra?.best_times ? `<div><strong>Best times:</strong> ${extra.best_times}</div>` : '',
          extra?.fav_food_books ? `<div><strong>Favorites:</strong> ${extra.fav_food_books}</div>` : '',
          extra?.comms ? `<div><strong>Communication:</strong> ${extra.comms}</div>` : '',
          extra?.strong_points ? `<div><strong>Strong points:</strong> ${extra.strong_points}</div>` : '',
          extra?.advice_topics ? `<div><strong>Ask me about:</strong> ${extra.advice_topics}</div>` : '',
          extra?.goals ? `<div><strong>Goals:</strong> ${extra.goals}</div>` : '',
          extra?.demotivation ? `<div><strong>Demotivation:</strong> ${extra.demotivation}</div>` : '',
          extra?.interests ? `<div><strong>Interests:</strong> ${extra.interests}</div>` : '',
          extra?.facts ? `<div><strong>Interesting fact(s):</strong> ${extra.facts}</div>` : '',
          extra?.traits ? `<div><strong>Traits:</strong> ${extra.traits}</div>` : ''
        ].filter(Boolean);
        return lines.join('\n');
      }

      async function openProfileModal(studentId, fallbackTitle, extra) {
        try {
          // Load student row
          let s = null; try { const { data } = await supabase.from('students').select('id, full_name, email, section').eq('id', studentId).limit(1); s = data?.[0]||null; } catch {}
          profileViewTitle.textContent = s?.full_name || fallbackTitle || 'Profile';
          // Avatar: prefer local data URL from extras (or localStorage for self), then remote, then generic
          let localData = extra?.avatar_data_url || null;
          if (!localData && (s?.id === user?.id || ((s?.email||'').toLowerCase() === (user?.email||'').toLowerCase()))) {
            try { const cur = JSON.parse(localStorage.getItem(lsKey())||'{}'); if (cur.avatar_data_url) localData = cur.avatar_data_url; } catch {}
            try { if (!localData && window.MY_LOCAL_AVATAR_DATA_URL) localData = window.MY_LOCAL_AVATAR_DATA_URL; } catch {}
          }
          if (localData) {
            try { profileViewAvatar.src = localData; } catch {}
          } else {
            profileViewAvatar.src = GENERIC_AVATAR;
          }
          try { profileViewAvatar.setAttribute('loading','lazy'); } catch {}
          const avatar = extra?.avatar_path || extra?.photo_path || extra?.avatar;
          const bkt = extra?.avatar_bucket || null;
          let modalSet = false;
          if (avatar) {
            try {
              const url = await getSignedAvatarUrl(avatar, bkt);
              if (url) {
                profileViewAvatar.onerror = () => { if (localData) profileViewAvatar.src = localData; else profileViewAvatar.src = GENERIC_AVATAR; };
                profileViewAvatar.src = url; modalSet = true;
              }
            } catch {}
          }
          if (!modalSet && localData) { try { profileViewAvatar.src = localData; } catch {} }
          // Info
          profileViewInfo.innerHTML = renderProfileInfoHtml(s||{}, extra||{});
          // Load comments
          await loadProfileComments(studentId);
          // Wire post
          profileCommentSaveBtn.onclick = async () => { await saveProfileComment(studentId); };
          profileViewModal.classList.add('show');
        } catch {}
      }
      profileViewCloseBtn?.addEventListener('click', () => profileViewModal.classList.remove('show'));

      async function loadProfileComments(studentId) {
        profileCommentsList.innerHTML = ''; profileCommentMsg.textContent = '';
        // Try dedicated table; fallback to generic comments
        let rows = [];
        try {
          if (await checkTableExists('profile_comments')) {
            const { data } = await supabase.from('profile_comments').select('id, created_at, commenter_id, student_id, text').eq('student_id', studentId).order('created_at', { ascending: false });
            rows = data || [];
          }
        } catch {}
        if (!rows.length) {
          try {
            if (await checkTableExists('comments')) {
              const { data } = await supabase.from('comments').select('*').eq('student_id', studentId).order('created_at', { ascending: false });
              rows = data || [];
            }
          } catch {}
        }
        if (!rows.length) { profileCommentsList.innerHTML = '<div class="muted">No comments yet.</div>'; return; }
        // Map names
        const ids = Array.from(new Set(rows.map(r=>r.commenter_id).filter(Boolean)));
        const nameById = new Map();
        if (ids.length) {
          try { const { data } = await supabase.from('students').select('id, full_name, email').in('id', ids); for (const s of (data||[])) nameById.set(s.id, s.full_name || s.email || s.id); } catch {}
        }
        for (const r of rows) {
          const who = nameById.get(r.commenter_id) || 'User';
          const div = document.createElement('div');
          div.className = 'group-box';
          div.innerHTML = `<div class="group-title"><strong>${who}</strong><span class="muted">${r.created_at ? new Date(r.created_at).toLocaleString() : ''}</span></div>
                           <div>${(r.text||'').replace(/[&<>]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]))}</div>`;
          profileCommentsList.appendChild(div);
        }
      }

      async function saveProfileComment(studentId) {
        profileCommentMsg.textContent = '';
        const text = (profileCommentInput?.value||'').trim();
        if (!text) { profileCommentMsg.textContent = 'Type a comment first.'; return; }
        profileCommentMsg.textContent = 'Posting…'; profileCommentSaveBtn.disabled = true;
        try {
          let ok = false;
          if (await checkTableExists('profile_comments')) {
            const r1 = await supabase.from('profile_comments').insert({ student_id: studentId, commenter_id: user.id, text }, { returning:'minimal' });
            ok = !r1.error;
          }
          if (!ok && await checkTableExists('comments')) {
            const r2 = await supabase.from('comments').insert({ student_id: studentId, commenter_id: user.id, text }, { returning:'minimal' });
            ok = !r2.error;
          }
          if (!ok) throw new Error('No comments table');
          profileCommentMsg.textContent = 'Posted.';
          profileCommentInput.value = '';
          await loadProfileComments(studentId);
        } catch { profileCommentMsg.textContent = 'Could not post (RLS/tables).'; }
        finally { profileCommentSaveBtn.disabled = false; }
      }

      // -------- Avatar cropping helper --------
      // Opens a lightweight crop UI, returns a Blob of the cropped image or null.
      async function openCropper(fileOrBlob) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => {
            const src = reader.result;
            // Build simple modal with canvas + draggable circle guide
            const m = document.createElement('div'); m.className='modal-backdrop show';
            const d = document.createElement('div'); d.className='modal-dialog'; d.style.width='min(560px,92vw)';
            d.innerHTML = `<h3>Crop your photo</h3>`;
            const wrap = document.createElement('div'); wrap.style.display='grid'; wrap.style.gap='8px'; wrap.style.placeItems='center';
            const canvas = document.createElement('canvas'); canvas.width=480; canvas.height=480; canvas.style.background='#000'; canvas.style.maxWidth='100%';
            const img = new Image(); img.onload = () => { draw(); } ; img.src = src;
            let offsetX = 0, offsetY = 0, scale = 1; let dragging=false, lastX=0, lastY=0;
            const ctx = canvas.getContext('2d');
            function draw() {
              ctx.clearRect(0,0,canvas.width,canvas.height);
              // background
              ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
              // image
              const iw = img.width * scale; const ih = img.height * scale;
              const cx = canvas.width/2 + offsetX; const cy = canvas.height/2 + offsetY;
              const ix = cx - iw/2; const iy = cy - ih/2; ctx.drawImage(img, ix, iy, iw, ih);
              // circle guide mask
              ctx.save(); ctx.globalCompositeOperation='destination-in';
              ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2 - 4, 0, Math.PI*2); ctx.fill(); ctx.restore();
              // faint border
              ctx.strokeStyle='rgba(255,255,255,.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2 - 4, 0, Math.PI*2); ctx.stroke();
            }
            function onDown(e){ dragging=true; const p = getPoint(e); lastX=p.x; lastY=p.y; e.preventDefault(); }
            function onMove(e){ if(!dragging) return; const p=getPoint(e); offsetX += (p.x-lastX); offsetY += (p.y-lastY); lastX=p.x; lastY=p.y; draw(); }
            function onUp(){ dragging=false; }
            function getPoint(e){ const r=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top; return {x,y}; }
            canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
            canvas.addEventListener('touchstart', onDown, { passive:false }); canvas.addEventListener('touchmove', onMove, { passive:false }); window.addEventListener('touchend', onUp);
            canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); const d = e.deltaY>0 ? 0.9 : 1.1; scale = Math.max(0.2, Math.min(5, scale*d)); draw(); }, { passive:false });
            wrap.appendChild(canvas);
            const actions = document.createElement('div'); actions.className='modal-actions';
            const cancel = document.createElement('button'); cancel.textContent='Cancel';
            const save = document.createElement('button'); save.textContent='Use Photo';
            cancel.onclick = ()=>{ document.body.removeChild(m); resolve(null); };
            save.onclick = ()=>{ canvas.toBlob((b)=>{ document.body.removeChild(m); resolve(b); }, 'image/jpeg', 0.9); };
            actions.append(cancel, save);
            d.appendChild(wrap); d.appendChild(actions); m.appendChild(d); document.body.appendChild(m);
          };
          reader.readAsDataURL(fileOrBlob);
        });
      }

      async function loadGroupsTab() {
        groupsList.innerHTML = '';
        groupEmpty.style.display = '';
        // Try to seed demo students if table empty
  await ensureDemoStudentsPresent({ force: false });
        const section = currentProfile?.section;
        if (!section) return;
  // Ensure 6 groups exist for this section
  await ensureSixGroups(section);
  // Optionally seed demo memberships if empty
  await ensureDemoGroupsAndMembers(section);
        try {
          // My group id
          let myGroupId = null;
          try {
            const { data: my } = await supabase.from('group_members').select('group_id').eq('student_id', user.id).limit(1);
            myGroupId = my?.[0]?.group_id || null;
          } catch {}
          // Fetch groups in section
          const { data: groups } = await supabase.from('groups').select('id,name').eq('section', section).order('name');
          if (!groups || !groups.length) { groupEmpty.style.display = ''; return; }
          // Fetch members for these groups
          const groupIds = groups.map(g => g.id);
          const { data: gms } = await supabase.from('group_members').select('group_id, student_id').in('group_id', groupIds);
          const studentIds = Array.from(new Set((gms || []).map(r => r.student_id)));
          let studentsById = new Map();
          if (studentIds.length) {
            const { data: studs } = await supabase.from('students').select('id, full_name, email').in('id', studentIds);
            for (const s of (studs || [])) studentsById.set(s.id, s);
          }
          // Build group -> members list
          const membersByGroup = new Map();
          for (const gid of groupIds) membersByGroup.set(gid, []);
          for (const r of (gms || [])) {
            const s = studentsById.get(r.student_id) || { id: r.student_id };
            membersByGroup.get(r.group_id)?.push(s);
          }
          // Sort groups with my group first
          const sorted = [...groups].sort((a,b) => (a.id === myGroupId ? -1 : b.id === myGroupId ? 1 : (a.name||'').localeCompare(b.name||'')));
          // Render
          groupEmpty.style.display = 'none';
          for (const g of sorted) {
            const box = document.createElement('div');
            box.className = 'group-box' + (g.id === myGroupId ? ' my' : '');
            const cap = `${(membersByGroup.get(g.id)||[]).length}/4`;
            box.innerHTML = `<div class="group-title"><strong>${g.name}</strong><span class="muted">${cap}</span></div>`;
            const ul = document.createElement('ul');
            ul.className = 'group-members';
            for (const s of (membersByGroup.get(g.id) || [])) {
              const li = document.createElement('li');
              li.className = 'group-member';
              li.textContent = s.full_name || s.email || s.id;
              ul.appendChild(li);
            }
            // Empty state per group
            if (!membersByGroup.get(g.id) || membersByGroup.get(g.id).length === 0) {
              const li = document.createElement('li');
              li.className = 'muted';
              li.textContent = 'No members yet';
              ul.appendChild(li);
            }
            box.appendChild(ul);
            groupsList.appendChild(box);
          }
        } catch {}
      }

  async function ensureDemoGroupsAndMembers(section) {
        try {
          // Count memberships in this section
          const { data: secGroups } = await supabase.from('groups').select('id').eq('section', section);
          const gIds = (secGroups || []).map(g => g.id);
          if (!gIds.length) return;
          const { count } = await supabase.from('group_members').select('group_id', { count: 'exact', head: true }).in('group_id', gIds);
          if (typeof count === 'number' && count > 0) return; // already has members
      // Load all students in this section
      const { data: studs } = await supabase.from('students').select('id').eq('section', section);
      const demoStuds = (studs || []);
      if (!demoStuds.length) return;
          // Round-robin assign up to 4 per group
          const inserts = [];
          let gi = 0; let perGroup = new Map(gIds.map(id => [id, 0]));
          for (const s of demoStuds) {
            // find next group with < 4 members
            let assigned = false;
            for (let k = 0; k < gIds.length; k++) {
              const gid = gIds[(gi + k) % gIds.length];
              const cnt = perGroup.get(gid) || 0;
              if (cnt < 4) {
        inserts.push({ group_id: gid, student_id: s.id });
                perGroup.set(gid, cnt + 1);
                gi = (gi + k + 1) % gIds.length;
                assigned = true;
                break;
              }
            }
            if (!assigned) break;
          }
          if (inserts.length) await supabase.from('group_members').insert(inserts);
        } catch {}
      }

      async function loadAssignments() {
        assignmentsTableBody.innerHTML = '';
        // Prefer Specifications assignments view: descriptors + per-student status/eval
        try {
          await resolveSpecTableName();
          const { data: descs } = await supabase.from(SPEC_TABLE_NAME).select('*');
          // Fetch student assignment statuses defensively (columns may differ)
          let stats = [];
          try {
            if (!user?.id) throw new Error('no-user');
            const r = await supabase.from('student_assignments').select('*').eq('student_id', user.id);
            stats = r.data || [];
          } catch {
            // Try alternate student column names
            try {
              if (!user?.id) throw new Error('no-user');
              const r2 = await supabase.from('student_assignments').select('*').eq('student', user.id);
              stats = r2.data || [];
            } catch {
              try {
                if (!user?.id) throw new Error('no-user');
                const r3 = await supabase.from('student_assignments').select('*').eq('user_id', user.id);
                stats = r3.data || [];
              } catch { stats = []; }
            }
          }
          const byAssign = new Map((stats||[]).map(s => [s.assignment_id, s]));
      if (descs && descs.length) {
            // Only show the seven canonical assignments; hide generics
            const defaults = ['Diagnostic Essay','Reflection 1','Reflection 2','Peer Reviews','Professional Portfolio','Literature Review Draft','Literature Review Final'];
            const norm = s => (s||'').toLowerCase().replace(/\s+/g,' ').trim();
            const allowed = new Set(defaults.map(norm));
            // Filter and dedupe by title (prefer rows with a doc_url)
            const byTitle = new Map();
            for (const row of (descs||[])) {
              const t = row.assignment_title ?? row.title ?? row.name;
              const key = norm(t);
              if (!allowed.has(key)) continue; // skip non-canonical
              const existing = byTitle.get(key);
              if (!existing || (!!row.doc_url && !existing.doc_url)) byTitle.set(key, row);
            }
            // Fill in any missing as virtual placeholders
            const presentKeys = new Set(byTitle.keys());
            for (const dflt of defaults) {
              const k = norm(dflt);
              if (!presentKeys.has(k)) byTitle.set(k, { id: `v-${k}`, assignment_title: dflt, doc_url: null, _virtual: true });
            }
            // Sort in the canonical order
            const order = new Map(defaults.map((t,i)=>[norm(t), i]));
            const list = Array.from(byTitle.entries()).sort((a,b)=>order.get(a[0]) - order.get(b[0])).map(([,v])=>v);
            for (const d of list) {
              const s = byAssign.get(d.id) || null;
              const status = s?.status || 'assigned';
              const cls = status === 'graded' ? 'ok' : status === 'submitted' ? 'warn' : '';
        const titleVal = d.assignment_title ?? d.title ?? d.name ?? 'Assignment';
        const docUrl = d.doc_url ?? d.link ?? d.url ?? null;
  const name = docUrl ? `<a href="${docUrl}" target="_blank" rel="noopener" style="background:#ffeb3b;color:#111;padding:0 3px;border-radius:3px;">${titleVal||'Assignment'}</a>` : (titleVal || 'Assignment');
              const tr = document.createElement('tr');
              const updatedAt = (s?.updated_at || s?.updatedAt || s?.updated_on || s?.last_updated || null);
              tr.innerHTML = `<td>${name}</td><td><span class="tag ${cls}">${status}</span></td><td>${updatedAt ? new Date(updatedAt).toLocaleDateString() : '—'}</td>`;
              assignmentsTableBody.appendChild(tr);
            }
            return;
          }
        } catch {}
        // Fallback to generic assignments/submissions tables if present
        try {
          // Try multiple column variants based on user's schema
          let assignments = [];
          try {
            const r1 = await supabase.from('assignments').select('id, title, due_at').order('due_at');
            assignments = r1.data || [];
          } catch {}
          if (!assignments.length) {
            try {
              const r2 = await supabase.from('assignments').select('id, description, due_date, assignment_type').order('due_date');
              assignments = (r2.data || []).map(a => ({ id: a.id, title: a.assignment_type || a.description || 'Assignment', due_at: a.due_date || null }));
            } catch {}
          }
          const { data: subs } = await supabase.from('submissions').select('assignment_id, status, updated_at').eq('student_id', user.id);
          const map = new Map((subs || []).map(s => [s.assignment_id, s]));
          if (assignments && assignments.length) {
            for (const a of assignments) {
              const s = map.get(a.id);
              const status = s?.status || 'Not Yet';
              const cls = status.toLowerCase().includes('meet') || status.toLowerCase().includes('submitted') ? 'ok' : status.toLowerCase().includes('approach') ? 'warn' : 'err';
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${a.title || 'Assignment'}</td><td><span class="tag ${cls}">${status}</span></td><td>${s?.updated_at ? new Date(s.updated_at).toLocaleDateString() : (a.due_at ? new Date(a.due_at).toLocaleDateString() : '—')}</td>`;
              assignmentsTableBody.appendChild(tr);
            }
            return;
          }
        } catch {}
        // Last-resort sample row
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>Sample Assignment</td><td><span class="tag warn">Approaching</span></td><td>—</td>`;
        assignmentsTableBody.appendChild(tr);
        // Also load peer review evaluations
        await loadPeerReviewEvaluations();
      }

      async function loadPeerReviewEvaluations() {
        if (!PEER_REVIEWS_EXISTS) return;
        if (!peerEvalList) return;
        peerEvalList.innerHTML = '';
        peerEvalEmpty.style.display = '';
        try {
          // Prefer '*' without server ordering; sort client-side when possible to avoid 400s from missing columns
          let recs = [];
          let prErr = null;
          try {
            const r = await supabase
              .from(PEER_REVIEWS_TABLE)
              .select('*')
              .eq('reviewee_id', user.id)
              .limit(50);
            recs = r.data || [];
            prErr = r.error || null;
          } catch (e) { prErr = e; }
          // client-side sort if created_at exists
          if (Array.isArray(recs) && recs.length && 'created_at' in recs[0]) {
            recs.sort((a,b)=> new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
          }
          if (prErr) {
            const msg = (prErr.message||'').toLowerCase();
            if (msg.includes('not found') || msg.includes('relation') || msg.includes('does not exist')) { PEER_REVIEWS_EXISTS = false; return; }
          }
          const rows = (recs || []);
          if (!rows.length) return;
          // map reviewer names
          const ids = Array.from(new Set(rows.map(r => r.reviewer_id)));
          const nameMap = new Map();
          if (ids.length) {
            const { data: studs } = await supabase.from('students').select('id, full_name, email').in('id', ids);
            (studs||[]).forEach(s => nameMap.set(s.id, s.full_name || s.email || s.id));
          }
          peerEvalEmpty.style.display = 'none';
          for (const r of rows) {
            const box = document.createElement('div');
            box.className = 'group-box';
            const who = (r.reviewer_id && nameMap.get(r.reviewer_id)) || 'Classmate';
            box.innerHTML = `
              <div class="group-title"><strong>${who}</strong><span class="muted">${r.assignment_type || ''} • ${r.created_at ? new Date(r.created_at).toLocaleDateString() : ''}</span></div>
              <div class="muted" style="margin-bottom:6px;">${(r.comments || '').slice(0,280)}</div>
            `;
            const sel = document.createElement('select'); sel.setAttribute('aria-label','Your evaluation'); sel.id = `peerEval_${Math.random().toString(36).slice(2)}`;
            ;['Exceeding Expectations','Meeting Expectations','Approaching Expectations','Not Yet'].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; sel.appendChild(o); });
            // Default to Not Yet; if an evaluation column exists on save we'll persist it, else fall back into comments
            sel.value = 'Not Yet';
            const btn = document.createElement('button'); btn.textContent = 'Save Evaluation';
            const msg = document.createElement('span'); msg.className = 'muted'; msg.style.marginLeft = '8px';
            const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px';
            const lab = document.createElement('label'); lab.textContent = 'Your evaluation:'; lab.htmlFor = sel.id; row.appendChild(lab);
            row.appendChild(sel); row.appendChild(btn); row.appendChild(msg);
            box.appendChild(row);
            btn.addEventListener('click', async () => {
              msg.textContent = 'Saving…'; btn.disabled = true;
              try {
                // Try to update evaluation column; fallback: append to comments if column missing
                let { error } = await supabase.from(PEER_REVIEWS_TABLE).update({ evaluation: sel.value }).eq('id', r.id);
                if (error) {
                  // Fallback: add marker into comments to persist choice
                  const newComments = `[Student Eval: ${sel.value}]\n${r.comments || ''}`;
                  ({ error } = await supabase.from(PEER_REVIEWS_TABLE).update({ comments: newComments }).eq('id', r.id));
                  if (error) throw error;
                }
                msg.textContent = 'Saved.';
                // remove box from list
                box.remove();
                if (!peerEvalList.children.length) peerEvalEmpty.style.display = '';
              } catch { msg.textContent = 'Save failed (RLS/policies).'; }
              finally { btn.disabled = false; }
            });
            peerEvalList.appendChild(box);
          }
        } catch {}
  }

      async function loadSpecs() {
        if (!specsTable) return;
        const tbody = specsTable.querySelector('tbody');
        tbody.innerHTML = '';
        specsEmpty.style.display = '';
        specsMsg.textContent = '';
        await resolveSpecTableName();

        // Get modal elements (early) and validate
        const editModal = document.getElementById('editSpecModal');
        const editAssignLabel = document.getElementById('editSpecAssignLabel');
        const editDocUrl = document.getElementById('editSpecDocUrl');
  const editExceedsLevel = document.getElementById('editALevel');
  const editMeetsLevel = document.getElementById('editBLevel');
  const editNotYetLevel = document.getElementById('editCLevel');
        const editCancelBtn = document.getElementById('editSpecCancelBtn');
        const editSaveBtn = document.getElementById('editSpecSaveBtn');

        if (!editModal || !editExceedsLevel || !editMeetsLevel || !editNotYetLevel || !editSaveBtn) {
          console.error('Edit modal elements not found in DOM');
          console.log('editModal:', editModal);
          console.log('editExceedsLevel:', editExceedsLevel);
          console.log('editMeetsLevel:', editMeetsLevel);
          console.log('editNotYetLevel:', editNotYetLevel);
          console.log('editSaveBtn:', editSaveBtn);
          specsMsg.textContent = 'Edit modal not properly initialized. Please refresh the page.';
          return;
        }
        const specsAdminActionsHead = document.getElementById('specsAdminActionsHead');

        // Probe if the table supports writing expected columns; if not, suppress auto-writes
        try {
          const { error: colErr } = await supabase.from(SPEC_TABLE_NAME).select('assignment_title').limit(1);
          if (colErr) SPEC_WRITES_AVAILABLE = false;
        } catch { SPEC_WRITES_AVAILABLE = false; }

        // Admin controls visibility
        specsAdmin.style.display = isAdmin ? '' : 'none';
        if (specsAdminActionsHead) specsAdminActionsHead.style.display = isAdmin ? '' : 'none';

        // Load descriptors
        let descriptors = [];
        try {
          const { data } = await supabase.from(SPEC_TABLE_NAME).select('*');
          descriptors = data || [];
        } catch {
          specsMsg.textContent = 'Could not load spec descriptors (RLS/tables).';
        }

        // Canonical set of seven only
        const defaults = [
          { assignment_title: 'Diagnostic Essay' },
          { assignment_title: 'Reflection 1' },
          { assignment_title: 'Reflection 2' },
          { assignment_title: 'Peer Reviews' },
          { assignment_title: 'Professional Portfolio' },
          { assignment_title: 'Literature Review Draft' },
          { assignment_title: 'Literature Review Final' }
        ];

        const norm = s => (s||'').toLowerCase().replace(/\s+/g,' ').trim();
        // Admin-only cleanup of generics: delete non-canonical descriptor rows once (optional)
        try {
          if (SPECS_AUTO_CLEAN && isAdmin && !_specsGenericsCleaned && descriptors && descriptors.length) {
            const allowed = new Set(defaults.map(x=>norm(x.assignment_title)));
            const extras = descriptors.filter(d => !allowed.has(norm(d.assignment_title ?? d.title ?? d.name)) && d.id);
            if (extras.length) {
              await resolveSpecTableName();
              await supabase.from(SPEC_TABLE_NAME).delete().in('id', extras.map(e=>e.id));
              // Reload descriptors after cleanup
              const { data } = await supabase.from(SPEC_TABLE_NAME).select('*');
              descriptors = data || [];
            }
            _specsGenericsCleaned = true;
          }
        } catch {}

        const titles = new Set(defaults.map(x=>norm(x.assignment_title)));
        // Keep only the seven canonical items from DB
        let merged = (descriptors||[]).filter(d => titles.has(norm(d.assignment_title ?? d.title ?? d.name)));
        const have = new Set(merged.map(d => norm(d.assignment_title ?? d.title ?? d.name)));
        const missing = defaults.filter(x => !have.has(norm(x.assignment_title)));

        // Auto-seed missing canonical rows for admins once to replace virtual placeholders (optional)
        if (SPECS_WRITES_ENABLED && SPEC_WRITES_AVAILABLE && SPECS_AUTO_SEED && isAdmin && !_specsAutoSeeding && missing.length) {
          try {
            await resolveSpecTableName();
            // Insert only required/guaranteed column to avoid schema mismatches
            const payload = missing.map(m => ({ assignment_title: m.assignment_title }));
            await safeUpsertSpecs(payload);
            _specsAutoSeeding = true;
            // Reload to show real rows
            await loadSpecs();
            return;
          } catch { _specsAutoSeeding = true; }
        }

        // Create virtual placeholders for any missing
        for (const x of missing) merged.push({ id: `v-${norm(x.assignment_title)}`, assignment_title: x.assignment_title, exceeds_expectations: '', meets_expectations: '', not_yet_meeting_expectations: '', _virtual: true });

        // Sort by the order defined in defaults
        const order = new Map(defaults.map((x,i)=>[norm(x.assignment_title), i]));
        merged.sort((a,b)=> (order.get(norm(a.assignment_title ?? a.title ?? a.name)) ?? 99) - (order.get(norm(b.assignment_title ?? b.title ?? b.name)) ?? 99));

        // Reference-only mode: no per-student statuses
        specsEmpty.style.display = 'none';
        // Clear any default-missing messaging
        if (isAdmin) specsMsg.textContent = '';

  let _editingSpec = null;

        const openEdit = (row) => {
          if (!isAdmin) return;
          _editingSpec = row;
          const titleVal = row.assignment_title ?? row.title ?? row.name ?? 'Assignment';
          // Use new column names with fallbacks
          const exceedsVal = row.exceeds_expectations ?? '';
          const meetsVal = row.meets_expectations ?? '';
          const notYetVal = row.not_yet_meeting_expectations ?? '';
          const docUrl = row.doc_url ?? row.link ?? row.url ?? null;

          // Check if elements exist before using them
          if (editAssignLabel) editAssignLabel.textContent = titleVal;
          if (editDocUrl) editDocUrl.value = docUrl || '';
          if (editExceedsLevel) editExceedsLevel.value = exceedsVal || '';
          if (editMeetsLevel) editMeetsLevel.value = meetsVal || '';
          if (editNotYetLevel) editNotYetLevel.value = notYetVal || '';

          if (editModal) editModal.style.display = 'block';
        };

        const closeEdit = () => { if (editModal) editModal.style.display = 'none'; _editingSpec = null; };
        if (editCancelBtn) editCancelBtn.onclick = closeEdit;

        if (editSaveBtn) editSaveBtn.onclick = async () => {
          if (!_editingSpec) return;
          if (!SPECS_WRITES_ENABLED || !SPEC_WRITES_AVAILABLE) {
            specsMsg.textContent = 'Specs writes are disabled (schema/RLS).';
            return;
          }

          specsMsg.textContent = 'Saving…';
          editSaveBtn.disabled = true;

          try {
            const patch = {
              assignment_title: (_editingSpec.assignment_title ?? _editingSpec.title ?? _editingSpec.name),
              doc_url: (editDocUrl?.value || '').trim() || null,
              // Use new column names
              exceeds_expectations: editExceedsLevel?.value || '',
              meets_expectations: editMeetsLevel?.value || '',
              not_yet_meeting_expectations: editNotYetLevel?.value || ''
            };

            const ok = await safeMergeSpecsByTitle([patch]);
            if (!ok) throw new Error('merge-failed');

            specsMsg.textContent = 'Saved.';
            closeEdit();
            await loadSpecs();
          } catch {
            specsMsg.textContent = 'Save failed (RLS/tables).';
          } finally {
            editSaveBtn.disabled = false;
          }
        };

        for (const d of merged) {
          const tr = document.createElement('tr');
          // Use new column names with fallbacks
          const titleVal = d.assignment_title ?? d.title ?? d.name ?? 'Assignment';
          const exceedsVal = d.exceeds_expectations ?? '';
          const meetsVal = d.meets_expectations ?? '';
          const notYetVal = d.not_yet_meeting_expectations ?? '';
          const docUrl = d.doc_url ?? d.link ?? d.url ?? null;

          // Assignment title (hotlink if doc_url)
          const tdTitle = document.createElement('td');
          if (docUrl) {
            const a = document.createElement('a');
            a.href = docUrl; a.target = '_blank'; a.rel = 'noopener'; a.textContent = titleVal || 'Assignment';
            // Yellow highlight for visibility
            a.style.backgroundColor = '#ffeb3b';
            a.style.padding = '0 3px';
            a.style.borderRadius = '3px';
            a.style.color = '#111';
            tdTitle.appendChild(a);
          } else {
            tdTitle.textContent = titleVal || 'Assignment';
          }
          tr.appendChild(tdTitle);

          // New column displays
          const tdExceeds = document.createElement('td'); tdExceeds.textContent = exceedsVal || '—'; tr.appendChild(tdExceeds);
          const tdMeets = document.createElement('td'); tdMeets.textContent = meetsVal || '—'; tr.appendChild(tdMeets);
          const tdNotYet = document.createElement('td'); tdNotYet.textContent = notYetVal || '—'; tr.appendChild(tdNotYet);

          // Actions (admin only)
          const tdAct = document.createElement('td');
          if (isAdmin) {
            const btn = document.createElement('button'); btn.textContent = 'Edit';
            btn.addEventListener('click', () => openEdit(d));
            tdAct.appendChild(btn);
          }
          tr.appendChild(tdAct);
          tbody.appendChild(tr);
        }

        // If admin and any of the seven are missing, just inform (no auto-seed UI)
        if (isAdmin && missing.length) {
          specsMsg.textContent = `Missing ${missing.length} default assignment(s).`;
        }

        // Hook Add Assignment (admin)
        if (isAdmin && specsAddBtn) {
          const modal = document.getElementById('addAssignModal');
          const titleIn = document.getElementById('addAssignTitleInput');
          const urlIn = document.getElementById('addAssignDocUrlInput');
          const aIn = document.getElementById('addAssignExceedsLevel');
          const bIn = document.getElementById('addAssignMeetsLevel');
          const cIn = document.getElementById('addAssignNotYetLevel');
          const saveBtn = document.getElementById('addAssignSaveBtn');
          const cancelBtn = document.getElementById('addAssignCancelBtn');

          // Check if critical elements exist
          if (!modal || !titleIn || !aIn || !bIn || !cIn || !saveBtn) {
            console.error('Add Assignment modal elements not found in DOM');
            console.log('modal:', modal);
            console.log('titleIn:', titleIn);
            console.log('aIn:', aIn);
            console.log('bIn:', bIn);
            console.log('cIn:', cIn);
            console.log('saveBtn:', saveBtn);
            specsMsg.textContent = 'Add Assignment modal not properly initialized. Please refresh the page.';
            return;
          }

          const openModal = () => { 
            if (modal) { 
              modal.classList.add('show'); 
              if (titleIn) titleIn.focus();
            } 
          };
          const closeModal = () => { if (modal) { modal.classList.remove('show'); } };

          specsAddBtn.onclick = openModal;
          if (cancelBtn) cancelBtn.onclick = closeModal;

          if (saveBtn) saveBtn.onclick = async () => {
            if (!SPECS_WRITES_ENABLED || !SPEC_WRITES_AVAILABLE) {
              specsMsg.textContent = 'Specs writes are disabled (schema/RLS).';
              return;
            }

            const title = (titleIn?.value || '').trim();
            if (!title) return;

            const doc = (urlIn?.value || '').trim() || null;
            const a = aIn?.value || '';
            const b = bIn?.value || '';
            const c = cIn?.value || '';

            specsMsg.textContent = 'Saving…';

            try {
              await resolveSpecTableName();
              const ok = await safeUpsertSpecs([{ assignment_title: title, doc_url: doc, exceeds_expectations: a, meets_expectations: b, not_yet_meeting_expectations: c }]);
              if (!ok) throw new Error('save-failed');

              specsMsg.textContent = 'Added.';
              closeModal();
              if (titleIn) titleIn.value = '';
              if (urlIn) urlIn.value = '';
              if (aIn) aIn.value = '';
              if (bIn) bIn.value = '';
              if (cIn) cIn.value = '';
              await loadSpecs();
              await loadAssignments();
            } catch {
              specsMsg.textContent = 'Add failed (RLS/tables).';
            }
          };
        }

        // Compute which rows could use example descriptors (any missing field)
        const needsExamples = (merged || []).filter(d => !d.exceeds_expectations || !d.meets_expectations || !d.not_yet_meeting_expectations);
        const specsFillExamplesBtn = document.getElementById('specsFillExamplesBtn');

        // Simple example text library using friendly keys
        const EXAMPLE_DESCRIPTORS = {
          'Diagnostic Essay': {
            exceeds_expectations: 'Insightful thesis; strong organization; thorough evidence; minimal errors.',
            meets_expectations: 'Clear thesis; adequate structure; sufficient evidence; minor errors.',
            not_yet_meeting_expectations: 'Attempted thesis; basic structure; limited evidence; frequent errors.'
          },
          'Reflection 1': {
            exceeds_expectations: 'Deep reflection with specific examples and growth insights.',
            meets_expectations: 'Solid reflection with examples; some insights on growth.',
            not_yet_meeting_expectations: 'Basic summary with limited reflection or examples.'
          },
          'Reflection 2': {
            exceeds_expectations: 'Connects experiences to learning goals with rich detail.',
            meets_expectations: 'Explains experiences and relates to goals.',
            not_yet_meeting_expectations: 'Lists experiences with minimal connection to goals.'
          },
          'Peer Reviews': {
            exceeds_expectations: 'Constructive, specific feedback with actionable suggestions.',
            meets_expectations: 'Clear feedback with some specific suggestions.',
            not_yet_meeting_expectations: 'General feedback with few specifics.'
          },
          'Professional Portfolio': {
            exceeds_expectations: 'Polished artifacts; tailored; reflective commentary; professional format.',
            meets_expectations: 'Complete artifacts; some tailoring; generally clear format.',
            not_yet_meeting_expectations: 'Basic artifacts; minimal tailoring; format issues present.'
          },
          'Literature Review Draft': {
            exceeds_expectations: 'Comprehensive coverage; synthesis of sources; clear structure.',
            meets_expectations: 'Good coverage; some synthesis; mostly clear structure.',
            not_yet_meeting_expectations: 'Limited coverage; mostly summary; structure needs work.'
          },
          'Literature Review Final': {
            exceeds_expectations: 'Refined synthesis; strong argument; meticulous editing.',
            meets_expectations: 'Coherent synthesis; clear argument; minor editing issues.',
            not_yet_meeting_expectations: 'Basic synthesis; developing argument; noticeable errors.'
          }
        };
        function exampleFor(title) {
          return EXAMPLE_DESCRIPTORS[title] || {
            exceeds_expectations: 'Top-level performance description (A).',
            meets_expectations: 'Proficient performance description (B).',
            not_yet_meeting_expectations: 'Developing performance description (C).'
          };
        }

        if (specsFillExamplesBtn) specsFillExamplesBtn.onclick = async () => {
          if (!SPECS_WRITES_ENABLED || !SPEC_WRITES_AVAILABLE) {
            specsMsg.textContent = 'Specs writes are disabled (schema/RLS).';
            return;
          }

          if (!needsExamples.length) {
            specsMsg.textContent = 'No blank descriptors to fill.';
            return;
          }

          specsMsg.textContent = 'Filling example descriptors…';

          try {
            // Build upsert payload using friendly keys only
            const payload = needsExamples.map(d => {
              const titleVal = d.assignment_title ?? d.title ?? d.name;
              const ex = exampleFor(titleVal);
              return {
                assignment_title: titleVal,
                // Only use new column names
                exceeds_expectations: d.exceeds_expectations || ex.exceeds_expectations,
                meets_expectations: d.meets_expectations || ex.meets_expectations,
                not_yet_meeting_expectations: d.not_yet_meeting_expectations || ex.not_yet_meeting_expectations
              };
            });

            const ok = await safeMergeSpecsByTitle(payload);
            if (!ok) throw new Error('merge-failed');

            specsMsg.textContent = 'Example descriptors added.';
            await loadSpecs();
          } catch {
            specsMsg.textContent = 'Fill failed (RLS/tables).';
          }
        };

        // Show the Fill button only when useful
        if (specsFillExamplesBtn) specsFillExamplesBtn.style.display = (isAdmin && needsExamples.length) ? '' : 'none';

        // If writes unavailable, hint how to fix
        if (!SPEC_WRITES_AVAILABLE) {
          specsMsg.innerHTML = 'Specs table is read-only or missing columns. To enable adding defaults, add column assignment_title and a primary key. See setup notes.';
        }
      }

  // No section/student filtering in reference-only mode

    async function saveDescriptorField(id, field, value) {
      specsMsg.textContent = 'Saving…';
      try {
        const patch = {}; 
        // Only handle new field names
        if (field === 'exceeds_expectations') patch.exceeds_expectations = value;
        else if (field === 'meets_expectations') patch.meets_expectations = value;
        else if (field === 'not_yet_meeting_expectations') patch.not_yet_meeting_expectations = value;
        else patch[field] = value;

        await resolveSpecTableName();
        const row = { id, ...patch };
        const { error } = await supabase.from(SPEC_TABLE_NAME).upsert(row, { returning: 'minimal' });
        if (error) throw error;
        specsMsg.textContent = 'Saved.';
      } catch { specsMsg.textContent = 'Save failed (RLS/tables).'; }
    }

  // Reference-only mode: student assignment editing is disabled.
  async function saveStudentAssignField() { return false; }
      function classStartDate(date, section) {
        const cfg = SECTION_SCHEDULES[section];
        if (!cfg) return null;
        const [h,m] = cfg.start.split(':').map(Number);
        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, 0, 0);
      }

  async function loadAttendanceMonth() {
        if (!attCalendar) return;
        attMonthLabel.textContent = attMonth.toLocaleString(undefined, { month: 'long', year: 'numeric' });
        attCalendar.innerHTML = '';
        const y = attMonth.getFullYear(); const m = attMonth.getMonth();
        const firstDayIdx = new Date(y, m, 1).getDay();
        const daysInMonth = new Date(y, m + 1, 0).getDate();
        for (let i = 0; i < firstDayIdx; i++) attCalendar.appendChild(document.createElement('div'));
        // Fetch this month's attendance for current user
        let byDate = new Map(); let byTs = new Map();
        try {
          const start = `${y}-${String(m+1).padStart(2,'0')}-01`;
          const end = `${y}-${String(m+1).padStart(2,'0')}-${String(daysInMonth).padStart(2,'0')}`;
          const { data } = await supabase.from('attendance').select('date,status,created_at').eq('student_id', user.id).gte('date', start).lte('date', end);
          (data||[]).forEach(r => { byDate.set(r.date, r.status); byTs.set(r.date, r.created_at); });
        } catch {}
        // Overlay local updates
        for (const [k,v] of attendanceOverlay.entries()) {
          if (k.startsWith(`${y}-${String(m+1).padStart(2,'0')}-`)) {
            byDate.set(k, v.status);
            if (v.created_at) byTs.set(k, v.created_at);
          }
        }
        const today = new Date(); const todayYMD = ymd(today);
        for (let d = 1; d <= daysInMonth; d++) {
          const cell = document.createElement('div');
          cell.className = 'day';
          cell.textContent = String(d);
          const dt = new Date(y, m, d); const key = ymd(dt);
          if (key === todayYMD) cell.classList.add('today');
          const status = byDate.get(key) || '—';
          const tag = document.createElement('div');
          tag.style.marginTop = '4px'; tag.style.fontSize = '10px'; tag.style.opacity = .9;
          const cls = status === 'absent' ? 'err' : status === 'late' ? 'warn' : status === 'present' ? 'ok' : '';
          const txt = status === 'present' ? 'P' : status === 'late' ? 'L' : status === 'absent' ? 'A' : '—';
          tag.innerHTML = `<span class="tag ${cls}">${txt}</span>`;
          cell.appendChild(tag);
          // Gray out future days
          if (dt > today) { cell.style.opacity = .5; cell.style.pointerEvents = 'none'; }
          // Dim non-class days
          if (!isClassDay(dt, currentProfile?.section || '')) { cell.classList.add('no-class'); }
          // Tooltip for recorded timestamp
          const ts = byTs.get(key);
          if (ts) cell.title = `Recorded: ${new Date(ts).toLocaleString()}`;
          attCalendar.appendChild(cell);
        }
  // Disable Mark Today if not a class day for user's section
        const markBtn = document.getElementById('markAttendanceBtn');
        if (markBtn) markBtn.disabled = !isClassDay(new Date(), currentProfile?.section || '');
  // Also refresh middle column weekly table
  await loadSectionAttendanceTable();
      }
      attPrevMonth?.addEventListener('click', () => { attMonth.setMonth(attMonth.getMonth()-1); loadAttendanceMonth(); });
      attNextMonth?.addEventListener('click', () => { attMonth.setMonth(attMonth.getMonth()+1); loadAttendanceMonth(); });

      // Determine Late threshold: when 5+ students have marked present today; first time that occurs + 10 minutes
    async function computeLateThreshold(section) {
        try {
          const today = new Date();
          // Use fixed schedule start + 10 minutes; only if it's a class day
          if (!isClassDay(today, section)) return null;
          const start = classStartDate(today, section);
          if (!start) return null;
          return new Date(start.getTime() + 10*60*1000);
        } catch { return null; }
      }

    document.getElementById('markAttendanceBtn').addEventListener('click', async () => {
        attendanceMsg.textContent = 'Saving…';
        const today = new Date(); const dateStr = ymd(today);
        try {
          if (!isClassDay(today, currentProfile?.section || '')) {
            attendanceMsg.textContent = 'No class today for your section.';
            return;
          }
          // Ensure FK target exists
          await ensureSelfStudentRow();
          // compute status: present if within window, else late if after threshold; default present if threshold not known
          let status = 'present';
          const threshold = await computeLateThreshold(currentProfile?.section || '');
          if (threshold && today > threshold) status = 'late';
          let { error } = await supabase.from('attendance').upsert({ student_id: user.id, date: dateStr, status }, { onConflict: 'student_id,date' });
          // If FK fails, try to create profile then retry once
          if (error && /foreign key|23503/i.test(String(error.message||''))) {
            await ensureSelfStudentRow();
            const retry = await supabase.from('attendance').upsert({ student_id: user.id, date: dateStr, status }, { onConflict: 'student_id,date' });
            error = retry.error;
          }
          if (error) throw error;
      // Update overlay for immediate UI
      attendanceOverlay.set(dateStr, { status, created_at: new Date().toISOString() });
      attendanceMsg.textContent = `Marked ${status}.`;
      await loadAttendanceMonth();
  // month loader will refresh the record
        } catch (e) {
          const msg = (e && (e.message || e.error?.message)) ? String(e.message || e.error?.message) : 'tables or RLS may not be configured';
          attendanceMsg.textContent = `Could not save attendance: ${msg}`;
          try { console.error('Attendance upsert failed:', e); } catch {}
        }
      });

      // Admin editor setup
      if (attendanceAdmin) attendanceAdmin.style.display = isAdmin ? '' : 'none';
  async function initAttendanceAdmin() {
        if (!isAdmin) return;
        const sections = await fetchSections();
        attAdminSection.innerHTML='';
        sections.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; attAdminSection.appendChild(o); });
        attAdminSection.value = currentProfile?.section && sections.includes(currentProfile.section) ? currentProfile.section : sections[0];
        await loadAdminStudents();
        const today = new Date(); attAdminDate.value = ymd(today);
  attAdminSection.addEventListener('change', async () => { await loadAdminStudents(); await loadSectionAttendanceTable(attAdminSection.value); });
        attAdminSave.addEventListener('click', saveAdminAttendance);
      }
      async function loadAdminStudents() {
        const sec = attAdminSection.value; attAdminStudent.innerHTML='';
        try {
          const { data } = await supabase.from('students').select('id, full_name, email').eq('section', sec).order('full_name');
          (data||[]).forEach(s=>{ const o=document.createElement('option'); o.value=s.id; o.textContent=s.full_name||s.email||s.id; attAdminStudent.appendChild(o); });
        } catch {}
      }
      async function saveAdminAttendance() {
        attAdminMsg.textContent = 'Saving…';
        try {
          const student_id = attAdminStudent.value; const date = attAdminDate.value; const status = attAdminStatus.value;
          if (!student_id || !date || !status) { attAdminMsg.textContent = 'Missing fields.'; return; }
          const { error } = await supabase.from('attendance').upsert({ student_id, date, status }, { onConflict: 'student_id,date' });
          if (error) throw error;
          // If admin edited the current user's record, clear any local overlay so DB value wins
          try {
            if (student_id === (user?.id || '')) {
              attendanceOverlay.delete(date);
            }
          } catch {}
          attAdminMsg.textContent = 'Saved.';
          await loadAttendanceMonth();
          // month loader will refresh the record
        } catch (e) { 
          const msg = (e && (e.message || e.error?.message)) ? String(e.message || e.error?.message) : 'RLS/policies';
          if (/foreign key|23503/i.test(msg)) {
            attAdminMsg.textContent = 'Save failed: selected student does not exist in students table (FK). Refresh list or create the student row first.';
          } else {
            attAdminMsg.textContent = `Save failed: ${msg}`;
          }
          try { console.error('Admin attendance upsert failed:', e); } catch {}
        }
      }

  // Initial load
  // Initialize attendance on first load as well
  loadAttendanceMonth();
  initAttendanceAdmin();
  // Ensure a single initial render (month will also refresh)
  loadAttendanceRecord();
  loadGroupsTab();
      loadAssignments();
      loadSpecs();

          // Optional: auto-clean non-canonical specs once for admins on initial load
          (async () => {
            if (!isAdmin || _specsGenericsCleaned) return;
            try {
              await resolveSpecTableName();
              const { data } = await supabase.from(SPEC_TABLE_NAME).select('*');
              const norm = s => (s||'').toLowerCase().replace(/\s+/g,' ').trim();
              const allowed = new Set(['diagnostic essay','reflection 1','reflection 2','peer reviews','professional portfolio','literature review draft','literature review final']);
              const extras = (data||[]).filter(d => !allowed.has(norm(d.assignment_title ?? d.title ?? d.name)) && d.id);
              if (extras.length) {
                await supabase.from(SPEC_TABLE_NAME).delete().in('id', extras.map(e=>e.id));
                _specsGenericsCleaned = true;
                await loadSpecs();
              }
            } catch {}
          })();

      // Sign out
      signOutBtn.addEventListener('click', () => signOutAndGo('index.html'));

      // ---------- Manage Groups (Admin) ----------
      async function fetchSections() {
        // Per request, restrict to these 3 sections only.
        return ['Section 5', 'Section 6', 'Section 7'];
      }

      async function ensureSixGroups(section) {
        // Ensure 6 groups exist for section named Group 1..6
        try {
          const { data: existing } = await supabase.from('groups').select('id,name').eq('section', section);
          const names = new Set((existing || []).map(g => g.name));
          const toCreate = [];
          for (let i = 1; i <= 6; i++) {
            const name = `Group ${i}`;
            if (!names.has(name)) toCreate.push({ name, section });
          }
          if (toCreate.length) await supabase.from('groups').insert(toCreate);
        } catch {}
      }

  async function loadManageGroups() {
  // Seed demo students if none exist so Manage Groups has data to work with
  await ensureDemoStudentsPresent({ force: false });
        // Build section pills
        const sections = await fetchSections();
        mgSections.innerHTML = '';
        for (const sec of sections) {
          const b = document.createElement('button');
          b.className = 'pill';
          b.textContent = sec;
          b.addEventListener('click', () => renderSection(sec));
          mgSections.appendChild(b);
        }
        // Select current user's section if present, otherwise first
        const preferred = currentProfile?.section && sections.includes(currentProfile.section)
          ? currentProfile.section
          : sections[0];
        if (preferred) renderSection(preferred);
      }

      async function renderSection(section) {
        // Active pill
        mgSections.querySelectorAll('.pill').forEach(p => p.classList.toggle('active', p.textContent === section));
        // Ensure groups exist
        await ensureSixGroups(section);
        // Optionally seed members for demo if none exist
        await ensureDemoGroupsAndMembers(section);
  mgStatus.textContent = '';
  // Fetch groups and members
        mgGrid.innerHTML = '';
        const unassignedEl = document.getElementById('mgUnassigned');
        unassignedEl.innerHTML = '';
        // Load students for this section
        let studs = [];
        try {
          const { data } = await supabase.from('students').select('id, full_name, email, section').eq('section', section).order('full_name');
          studs = data || [];
        } catch {}
        // Handle empty-state message once
        const existingMsg = document.getElementById('mgNoStudentsMsg');
        if (existingMsg) existingMsg.remove();
        if (!studs.length) {
          const msg = document.createElement('div');
          msg.id = 'mgNoStudentsMsg';
          msg.className = 'muted';
          msg.style.marginBottom = '8px';
          msg.textContent = 'No students visible for this section. If you are using RLS, ensure admin read access to students or click "Seed Demo Data".';
          mgGrid.parentElement.insertBefore(msg, mgGrid);
        }
        let groups = [];
        try {
          const { data } = await supabase.from('groups').select('id,name').eq('section', section).order('name');
          groups = data || [];
        } catch {}
        // Fill to 6
        for (let i = groups.length + 1; i <= 6; i++) {
          groups.push({ id: null, name: `Group ${i}` });
        }

        // Track assigned set
        const assigned = new Set();
        // For each group, fetch up to 4 members
  for (const g of groups.slice(0,6)) {
          let members = [];
          if (g.id) {
            try {
              const { data: gm } = await supabase.from('group_members').select('student_id').eq('group_id', g.id);
              const ids = (gm || []).map(x => x.student_id);
              ids.forEach(id => assigned.add(id));
              if (ids.length) {
                const { data: studs } = await supabase.from('students').select('id,full_name,email').in('id', ids).order('full_name');
                members = studs || [];
              }
            } catch {}
          }
          const box = document.createElement('div');
          box.className = 'mg-group';
          const cap = `${members.length}/4`;
          box.innerHTML = `<h3>${g.name}</h3><div class=\"mg-cap\">Capacity: ${cap}</div>`;
          const ul = document.createElement('ul');
          ul.className = 'mg-list drop-target';
          ul.dataset.groupId = g.id || '';
          // DnD drop handlers
          ul.addEventListener('dragover', e => e.preventDefault());
          ul.addEventListener('drop', async e => {
            e.preventDefault();
            const studentId = e.dataTransfer.getData('studentId');
            await moveStudentToGroup(studentId, g.id, section);
            renderSection(section);
          });
          for (const m of members.slice(0,4)) {
            const li = document.createElement('li');
            li.className = 'mg-student';
            li.draggable = true;
            li.dataset.studentId = m.id;
            li.addEventListener('dragstart', e => {
              e.dataTransfer.setData('studentId', m.id);
            });
            li.textContent = m.full_name || m.email || m.id;
            ul.appendChild(li);
          }
          // If fewer than 4, show empty slots
          for (let s = members.length; s < 4; s++) {
            const li = document.createElement('li');
            li.className = 'muted';
            li.textContent = '— empty —';
            ul.appendChild(li);
          }
          box.appendChild(ul);
          mgGrid.appendChild(box);
        }

  // Unassigned: students in section not in assigned set
        for (const s of studs) {
          if (!assigned.has(s.id)) {
            const li = document.createElement('li');
            li.className = 'mg-student';
            li.draggable = true;
            li.dataset.studentId = s.id;
            li.addEventListener('dragstart', e => {
              e.dataTransfer.setData('studentId', s.id);
            });
            li.textContent = s.full_name || s.email || s.id;
            unassignedEl.appendChild(li);
          }
        }
        // Dropping back to unassigned removes from groups in this section
        unassignedEl.addEventListener('dragover', e => e.preventDefault());
        unassignedEl.addEventListener('drop', async e => {
          e.preventDefault();
          const studentId = e.dataTransfer.getData('studentId');
          await removeStudentFromSectionGroups(studentId, section);
          renderSection(section);
        });

        // Status counts
        try {
          const { count: gmCount } = await supabase.from('group_members').select('group_id', { count: 'exact', head: true }).in('group_id', (groups||[]).filter(g=>g.id).map(g=>g.id));
          mgStatus.textContent = `Section: ${section} • Students: ${studs.length} • Groups: ${(groups||[]).filter(g=>g.id).length} • Memberships: ${gmCount ?? 0}`;
        } catch { mgStatus.textContent = `Section: ${section} • Students: ${studs.length} • Groups: ${(groups||[]).filter(g=>g.id).length}`; }
      }

      // Move helper: remove from any group in section then insert
      async function moveStudentToGroup(studentId, groupId, section) {
        if (!groupId) return;
        try {
          const { data: secGroups } = await supabase.from('groups').select('id').eq('section', section);
          const ids = (secGroups || []).map(g => g.id);
          if (ids.length) await supabase.from('group_members').delete().eq('student_id', studentId).in('group_id', ids);
          // Capacity check: count current members
          const { count } = await supabase.from('group_members').select('student_id', { count: 'exact', head: true }).eq('group_id', groupId);
          if (typeof count === 'number' && count >= 4) return; // full
          const { error } = await supabase.from('group_members').insert({ student_id: studentId, group_id: groupId });
          if (error) throw error;
          if (mgStatus) mgStatus.textContent = 'Student moved.';
        } catch (e) { if (mgStatus) mgStatus.textContent = 'Move failed (RLS or permissions).'; }
      }

      async function removeStudentFromSectionGroups(studentId, section) {
        try {
          const { data: secGroups } = await supabase.from('groups').select('id').eq('section', section);
          const ids = (secGroups || []).map(g => g.id);
          if (ids.length) {
            const { error } = await supabase.from('group_members').delete().eq('student_id', studentId).in('group_id', ids);
            if (error) throw error;
            if (mgStatus) mgStatus.textContent = 'Removed from groups in this section.';
          }
        } catch (e) { if (mgStatus) mgStatus.textContent = 'Remove failed (RLS or permissions).'; }
      }

      // Seed demo data across all sections
      async function seedDemoDataAllSections() {
        const added = await ensureDemoStudentsPresent({ force: true });
        const secs = await fetchSections();
        for (const sec of secs) {
          await ensureSixGroups(sec);
          await ensureDemoGroupsAndMembers(sec);
        }
        if (mgStatus) mgStatus.textContent = `Seed complete. Added ${added} demo students.`;
      }
      mgSeedBtn?.addEventListener('click', async () => {
        mgSeedBtn.disabled = true; mgSeedBtn.textContent = 'Seeding…';
        try { await seedDemoDataAllSections(); if (mgStatus) mgStatus.textContent = 'Demo data seeded (where permitted).'; } finally {
          mgSeedBtn.disabled = false; mgSeedBtn.textContent = 'Seed Demo Data';
          // Re-render current active section
          const active = Array.from(mgSections.querySelectorAll('.pill')).find(p => p.classList.contains('active'))?.textContent || (await fetchSections())[0];
          if (active) renderSection(active);
        }
      });

      // Randomize students across groups in the current section
      async function randomizeSection(section) {
        mgStatus.textContent = 'Randomizing…';
        try {
          await ensureSixGroups(section);
          const { data: secGroups } = await supabase.from('groups').select('id').eq('section', section).order('name');
          const gIds = (secGroups || []).map(g => g.id);
          if (!gIds.length) { mgStatus.textContent = 'No groups in this section.'; return; }
          const { data: studs } = await supabase.from('students').select('id').eq('section', section);
          const students = (studs || []).map(s => s.id);
          if (!students.length) { mgStatus.textContent = 'No students to assign.'; return; }
          // Clear existing memberships for these groups
          await supabase.from('group_members').delete().in('group_id', gIds);
          // Shuffle students
          for (let i = students.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [students[i], students[j]] = [students[j], students[i]]; }
          // Assign round-robin, up to 4 per group
          const inserts = [];
          const counts = new Map(gIds.map(id => [id, 0]));
          let gi = 0;
          for (const sid of students) {
            let placed = false; let tries = 0;
            while (!placed && tries < gIds.length) {
              const gid = gIds[gi];
              const c = counts.get(gid) || 0;
              if (c < 4) {
                inserts.push({ group_id: gid, student_id: sid });
                counts.set(gid, c + 1);
                placed = true;
              }
              gi = (gi + 1) % gIds.length; tries++;
            }
            if (!placed) break; // all groups full
          }
          if (inserts.length) await supabase.from('group_members').insert(inserts);
          mgStatus.textContent = 'Randomized.';
        } catch (e) {
          mgStatus.textContent = 'Could not randomize (RLS or permissions).';
        }
        // Refresh
        await renderSection(section);
      }
      mgRandomBtn?.addEventListener('click', async () => {
        const active = Array.from(mgSections.querySelectorAll('.pill')).find(p => p.classList.contains('active'))?.textContent || (await fetchSections())[0];
        if (active) await randomizeSection(active);
      });

      // Normalize sections: delete typo 'Sectio *' groups, rename Section A/B/C to 5/6/7 in both groups and students, and fix 'Sectio 5/6/7' student sections.
      async function normalizeSections() {
        if (!confirm('This will delete typo groups and rename sections to only Section 5/6/7. Continue?')) return;
        mgStatus.textContent = 'Fixing sections…';
        try {
          // 1) Delete groups with typo 'Sectio%'
          let gTypoIds = [];
          try {
            const { data: typoGs } = await supabase.from('groups').select('id').ilike('section', 'Sectio%');
            gTypoIds = (typoGs || []).map(g => g.id);
          } catch {}
          if (gTypoIds.length) {
            try { await supabase.from('group_members').delete().in('group_id', gTypoIds); } catch {}
            try { await supabase.from('groups').delete().in('id', gTypoIds); } catch {}
          }

          // 2) Rename Section A/B/C -> 5/6/7 in groups and students
          const map = [ ['Section A','Section 5'], ['Section B','Section 6'], ['Section C','Section 7'] ];
          for (const [from, to] of map) {
            try { await supabase.from('groups').update({ section: to }).eq('section', from); } catch {}
            try { await supabase.from('students').update({ section: to }).eq('section', from); } catch {}
          }

          // 3) Fix students with typo 'Sectio 5/6/7' -> 'Section 5/6/7'
          for (const n of ['5','6','7']) {
            try { await supabase.from('students').update({ section: `Section ${n}` }).eq('section', `Sectio ${n}`); } catch {}
          }

          // 4) Ensure only Section 5/6/7 groups exist: remove other section groups (non-destructive option is to keep; but user requested only 5/6/7)
          try {
            const keep = new Set(['Section 5','Section 6','Section 7']);
            const { data: allGs } = await supabase.from('groups').select('id, section');
            const delIds = (allGs || []).filter(g => !keep.has(g.section)).map(g => g.id);
            if (delIds.length) {
              try { await supabase.from('group_members').delete().in('group_id', delIds); } catch {}
              try { await supabase.from('groups').delete().in('id', delIds); } catch {}
            }
          } catch {}

          // 5) Recreate any missing groups for 5/6/7 and seed members if empty
          for (const s of ['Section 5','Section 6','Section 7']) {
            await ensureSixGroups(s);
            await ensureDemoGroupsAndMembers(s);
          }

          mgStatus.textContent = 'Sections normalized to 5/6/7.';
        } catch {
          mgStatus.textContent = 'Could not fix sections (RLS/policies may block).';
        }
        // Refresh UI
  await loadManageGroups();
      }
      mgNormalizeBtn?.addEventListener('click', normalizeSections);

      // ---------- Peer Reviews ----------
      async function loadPeerReviews() {
  await loadPeerReceived();
  await loadMyPortfolio();
        // Reset forms area and add one form
        peerReviewForms.innerHTML = '';
        await addPeerReviewForm();
      }

      function statusToTagClass(status) {
        const s = (status || '').toLowerCase();
  if (s.includes('exceed') || s.includes('meeting') || s.includes('meets') || s.includes('met') || s.startsWith('a level')) return 'ok';
  if (s.includes('approach') || s.startsWith('c level')) return 'warn';
        return 'err';
      }

      async function loadPeerReceived() {
  peerReceived.innerHTML = '';
        peerReceivedEmpty.style.display = '';
  try {
    if (!PEER_REVIEWS_EXISTS) return;
          let recs = [];
          let prErr2 = null;
          try {
            const r = await supabase
              .from(PEER_REVIEWS_TABLE)
              .select('*')
              .eq('reviewee_id', user.id)
              .limit(8);
            recs = r.data || [];
            prErr2 = r.error || null;
          } catch (e) { prErr2 = e; }
          if (Array.isArray(recs) && recs.length && 'created_at' in recs[0]) {
            recs.sort((a,b)=> new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
          }
          if (prErr2) {
            const msg = (prErr2.message||'').toLowerCase();
            if (msg.includes('not found') || msg.includes('relation') || msg.includes('does not exist')) { PEER_REVIEWS_EXISTS = false; return; }
          }
          if (!recs || !recs.length) return;
          // fetch reviewer names
          const ids = Array.from(new Set(recs.map(r => r.reviewer_id)));
          let nameById = new Map();
          if (ids.length) {
            const { data: studs } = await supabase.from('students').select('id, full_name, email').in('id', ids);
            for (const s of (studs||[])) nameById.set(s.id, s.full_name || s.email || s.id);
          }
          peerReceivedEmpty.style.display = 'none';
          const legend = document.getElementById('peerReceivedLegend');
          if (legend) legend.style.display = '';
          for (const r of recs) {
            const div = document.createElement('div');
            div.className = 'kv';
            const who = (r.reviewer_id && nameById.get(r.reviewer_id)) || 'Classmate';
            const specsText = (r.specs ?? '—');
            const evalText = (r.evaluation ?? 'Not Yet');
            const tag = statusToTagClass(specsText);
            const evalCls = statusToTagClass(evalText);
            div.innerHTML = `<div class="k">${who} • ${r.assignment_type || ''} • ${r.created_at ? new Date(r.created_at).toLocaleDateString() : ''}</div>
                             <div class="v"><span class="tag ${tag}">${specsText}</span> &nbsp; <span title="Your evaluation" class="tag ${evalCls}">${evalText}</span></div>
                             <div class="k" style="grid-column:1 / -1; color: var(--muted);">${(r.comments || '').slice(0,280)}</div>`;
            peerReceived.appendChild(div);
          }
        } catch {}
        finally {
          // If still empty, hide legend
          const legend = document.getElementById('peerReceivedLegend');
          if (legend && peerReceived.children.length === 0) legend.style.display = 'none';
        }
      }

      async function getClassmates() {
        const section = currentProfile?.section;
        if (!section) return [];
        try {
          const { data } = await supabase.from('students').select('id, full_name, email').eq('section', section).neq('id', user.id).order('full_name');
          return data || [];
        } catch { return []; }
      }

      function buildReviewForm(classmates, assignType) {
        const wrap = document.createElement('div');
        wrap.className = 'group-box';
  const sel = document.createElement('select'); sel.name = 'revieweeId'; sel.setAttribute('aria-label','Select classmate to review'); sel.id = `revieweeId_${Math.random().toString(36).slice(2)}`;
        for (const s of classmates) {
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = s.full_name || s.email || s.id;
          sel.appendChild(opt);
        }
    const ta = document.createElement('textarea');
  ta.rows = 6; ta.placeholder = 'Write your comments...'; ta.name = 'reviewComments'; ta.setAttribute('aria-label','Review comments'); ta.id = `reviewComments_${Math.random().toString(36).slice(2)}`;
        // Anti-paste/automation guards for dynamic review textareas
        try { attachNoPaste(ta, { message: 'Paste is disabled in review comments to encourage authentic feedback.' }); attachAntiAutoType(ta); } catch {}
    const spec = document.createElement('select'); spec.name = 'reviewSpecs'; spec.setAttribute('aria-label','Specs evaluation'); spec.id = `reviewSpecs_${Math.random().toString(36).slice(2)}`;
        [
          'A Level: Exceeding',
          'B Level: Meeting Expectations',
          'C Level: Approaching Expectations'
        ].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; spec.appendChild(o); });
        const submit = document.createElement('button');
        submit.type = 'button';
        submit.textContent = 'Submit Review';
        const msg = document.createElement('div');
        msg.className = 'muted';
        msg.style.marginTop = '6px';
        wrap.appendChild(Object.assign(document.createElement('div'), { innerHTML: `<div class="group-title"><strong>New Review</strong><span class="muted">${assignType}</span></div>` }));
  const classmateLbl = document.createElement('label'); classmateLbl.textContent = 'Select classmate'; classmateLbl.htmlFor = sel.id;
  wrap.appendChild(classmateLbl);
  wrap.appendChild(sel);
        // For Professional Portfolio, allow selecting a specific piece
        let pieceWrap = null; let pieceSel = null;
        if (assignType === 'Professional Portfolio') {
          pieceWrap = document.createElement('div');
          pieceWrap.style.margin = '6px 0';
          const lbl = document.createElement('label'); lbl.textContent = 'Select portfolio piece (if available)';
          pieceSel = document.createElement('select'); pieceSel.name = 'reviewPortfolioPiece'; pieceSel.setAttribute('aria-label','Select portfolio piece'); pieceSel.id = `reviewPortfolioPiece_${Math.random().toString(36).slice(2)}`; lbl.htmlFor = pieceSel.id;
          pieceWrap.appendChild(lbl); pieceWrap.appendChild(pieceSel);
          wrap.appendChild(pieceWrap);
          // load pieces for selected classmate
          const loadPieces = async (studentId) => {
            pieceSel.innerHTML = '';
            try {
              if (!PEER_SUBMISSIONS_EXISTS) { const o = document.createElement('option'); o.value = ''; o.textContent = 'Unavailable'; pieceSel.appendChild(o); return; }
              const { data, error: psErr } = await supabase.from(PEER_SUBMISSIONS_TABLE).select('id, created_at, text, file_path, title, category').eq('student_id', studentId).eq('assignment_type','Professional Portfolio').order('created_at', { ascending:false });
              if (psErr) { PEER_SUBMISSIONS_EXISTS = false; const o = document.createElement('option'); o.value = ''; o.textContent = 'Unavailable'; pieceSel.appendChild(o); return; }
              const rows = data || [];
              if (!rows.length) {
                const o = document.createElement('option'); o.value = ''; o.textContent = 'No portfolio pieces yet'; pieceSel.appendChild(o);
              } else {
                for (const r of rows) {
                  const cat = r.category || guessCategoryFromText(r.text) || 'Portfolio';
                  const ttl = r.title || guessTitleFromText(r.text) || '';
                  const d = new Date(r.created_at).toLocaleDateString();
                  const o = document.createElement('option');
                  o.value = r.id; o.textContent = `${cat}${ttl? ' — '+ttl:''} • ${d}`;
                  pieceSel.appendChild(o);
                }
              }
            } catch { const o = document.createElement('option'); o.value = ''; o.textContent = 'Unavailable'; pieceSel.appendChild(o); }
          };
          sel.addEventListener('change', () => loadPieces(sel.value));
          if (sel.value) loadPieces(sel.value);
        }
  const cmLbl = document.createElement('label'); cmLbl.textContent = 'Comments'; cmLbl.htmlFor = ta.id;
  wrap.appendChild(cmLbl);
        wrap.appendChild(ta);
  const spLbl = document.createElement('label'); spLbl.textContent = 'Specs Evaluation'; spLbl.htmlFor = spec.id;
  wrap.appendChild(spLbl);
        wrap.appendChild(spec);
        wrap.appendChild(submit);
        wrap.appendChild(msg);
        submit.addEventListener('click', async () => {
          const reviewee = sel.value;
          const comments = ta.value.trim();
          const specsVal = spec.value;
          msg.textContent = 'Saving…';
          try {
            // Try extended insert with optional portfolio metadata
            let payload = { reviewer_id: user.id, reviewee_id: reviewee, assignment_type: assignType, comments, specs: specsVal };
            if (assignType === 'Professional Portfolio') {
              const chosen = pieceSel?.value || '';
              const chosenId = chosen && !isNaN(chosen) ? Number(chosen) : chosen;
              payload = { ...payload, submission_id: chosenId || null };
              const cat = reviewPortfolioCategory?.value || null; if (cat) payload.portfolio_category = cat;
            }
            let { error } = await supabase.from(PEER_REVIEWS_TABLE).insert(payload, { returning: 'minimal' });
            if (error) {
              // Fallback without extra columns
              payload = { reviewer_id: user.id, reviewee_id: reviewee, assignment_type: assignType, comments: (assignType==='Professional Portfolio' ? `[Portfolio ${reviewPortfolioCategory?.value||''}] ` : '') + comments, specs: specsVal };
              ({ error } = await supabase.from(PEER_REVIEWS_TABLE).insert(payload, { returning: 'minimal' }));
              if (error) throw error;
            }
            msg.textContent = 'Review submitted.';
            await loadPeerReceived();
          } catch {
            msg.textContent = 'Could not save review (tables or RLS may not be configured).';
          }
        });
        return wrap;
      }

  async function addPeerReviewForm() {
        const classmates = await getClassmates();
        if (!classmates.length) {
          const d = document.createElement('div');
          d.className = 'muted';
          d.textContent = 'No classmates available.';
          peerReviewForms.appendChild(d);
          return;
        }
        const assignType = reviewAssignType.value;
        const form = buildReviewForm(classmates, assignType);
        peerReviewForms.appendChild(form);
      }

      addReviewFormBtn?.addEventListener('click', async () => { await addPeerReviewForm(); });

      // Toggle extras visibility based on selected types
      function togglePortfolioExtras() {
        const isPort = peerAssignType.value === 'Professional Portfolio';
        if (portfolioExtras) portfolioExtras.style.display = isPort ? '' : 'none';
      }
      peerAssignType?.addEventListener('change', togglePortfolioExtras);
      togglePortfolioExtras();

      // Apply paste and automation protections on reflection textarea
      try {
        if (peerText) {
          attachNoPaste(peerText, { message: 'Pasting is disabled for reflections. Please write in your own words.' });
          attachAntiAutoType(peerText);
        }
      } catch {}

      function toggleReviewPortfolio() {
        const isPort = reviewAssignType.value === 'Professional Portfolio';
        if (reviewPortfolioWrap) reviewPortfolioWrap.style.display = isPort ? '' : 'none';
      }
      reviewAssignType?.addEventListener('change', () => { toggleReviewPortfolio(); peerReviewForms.innerHTML=''; addPeerReviewForm(); });
      toggleReviewPortfolio();

  // Apply paste + automation protections to the Reflections tab textarea
  try { if (reflText) { attachNoPaste(reflText, { message: 'Pasting is disabled for reflections. Please write in your own words.' }); attachAntiAutoType(reflText); } } catch {}

      peerSubmitForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        peerSubmitMsg.textContent = '';
        const assignType = peerAssignType.value;
        const text = (peerText.value || '').trim();
        const file = peerFile.files?.[0] || null;
        const url = (peerUrl?.value || '').trim();
        if (!PEER_SUBMISSIONS_EXISTS) { peerSubmitMsg.textContent = 'Portfolio submissions are not available in this deployment.'; return; }
        if (!text && !file && !url) {
          peerSubmitMsg.textContent = 'Please upload a document, include a URL, or enter text.';
          return;
        }
        let file_path = null;
        if (file) {
          try {
            const path = `${user.id}/${Date.now()}_${file.name}`;
            const { error: upErr } = await supabase.storage.from('peer-submissions').upload(path, file, { upsert: false });
            if (!upErr) file_path = path;
          } catch {}
        }
        try {
          let payload = { student_id: user.id, assignment_type: assignType, text: text || null, file_path };
          if (url) payload.url = url;
          if (assignType === 'Professional Portfolio') {
            if (portfolioCategory) payload.category = portfolioCategory.value;
            if (portfolioTitle && portfolioTitle.value) payload.title = portfolioTitle.value.trim();
          }
          let { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).insert(payload, { returning: 'minimal' });
          if (error) {
            // Fallback for schemas without category/title columns
            const prefix = assignType === 'Professional Portfolio' ? `[${portfolioCategory?.value||'Portfolio'}${portfolioTitle?.value? ' • '+portfolioTitle.value : ''}]\n` : '';
            const fullText = (prefix + (text||'')) || null;
            const fallbackPayload = { student_id: user.id, assignment_type: assignType, text: fullText, file_path };
            if (url) fallbackPayload.text = `${fullText ? fullText + '\n' : ''}URL: ${url}`;
            ({ error } = await supabase.from(PEER_SUBMISSIONS_TABLE).insert(fallbackPayload, { returning: 'minimal' }));
            if (error) throw error;
          }
          peerSubmitMsg.textContent = 'Submission saved.';
          peerText.value = '';
          if (peerFile) peerFile.value = '';
          if (peerUrl) peerUrl.value = '';
          if (portfolioTitle) portfolioTitle.value='';
          await loadMyPortfolio();
        } catch {
          peerSubmitMsg.textContent = 'Could not save submission (tables, storage, or RLS may not be configured).';
        }
      });

      // Portfolio helpers
      function guessCategoryFromText(s) {
        const t = (s||'').toLowerCase();
        const cats = ['plan of action proposal','cv','cover letter','scholarship','exchange','internship','linkedin'];
        for (const c of cats) if (t.includes(c)) return c.replace(/\b\w/g, m=>m.toUpperCase());
        return null;
      }

      // ---------- Reflections Tab ----------
      async function loadReflections() {
        // Load received items
        await loadReflReceived();
        // Reset forms and add one
        if (reflReviewForms) { reflReviewForms.innerHTML = ''; await addReflReviewForm(); }
      }

      async function loadReflReceived() {
        if (!reflReceived) return;
        reflReceived.innerHTML = '';
        if (reflReceivedEmpty) reflReceivedEmpty.style.display = '';
        try {
          if (!PEER_REVIEWS_EXISTS) return;
          // Always avoid server filtering to prevent 400s on schemas without assignment_type
          let prErr = null; let recs = [];
          try {
            const r = await supabase
              .from(PEER_REVIEWS_TABLE)
              .select('*')
              .eq('reviewee_id', user.id)
              .limit(50);
            recs = r.data || [];
            prErr = r.error || null;
          } catch (e) { prErr = e; }
          if (Array.isArray(recs) && recs.length && 'created_at' in recs[0]) {
            recs.sort((a,b)=> new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
          }
          if (prErr) {
            const msg = (prErr.message||'').toLowerCase();
            if (msg.includes('not found') || msg.includes('relation') || msg.includes('does not exist')) { PEER_REVIEWS_EXISTS = false; return; }
          }
          // Client-filter to only Reflections (either explicit column or comment tag)
          recs = (recs || []).filter(x => (x.assignment_type === 'Reflections') || (typeof x.assignment_type === 'undefined' && typeof x.comments === 'string' && x.comments.startsWith('[Reflections] ')));
          if (!recs || !recs.length) return;
          // fetch reviewer names
          const ids = Array.from(new Set(recs.map(r => r.reviewer_id)));
          let nameById = new Map();
          if (ids.length) {
            const { data: studs } = await supabase.from('students').select('id, full_name, email').in('id', ids);
            for (const s of (studs||[])) nameById.set(s.id, s.full_name || s.email || s.id);
          }
          reflReceivedEmpty.style.display = 'none';
          const legend = document.getElementById('reflReceivedLegend');
          if (legend) legend.style.display = '';
          for (const r of recs) {
            const div = document.createElement('div');
            div.className = 'kv';
            const who = (r.reviewer_id && nameById.get(r.reviewer_id)) || 'Classmate';
            const specsText = (r.specs ?? '—');
            const evalText = (r.evaluation ?? 'Not Yet');
            const tag = statusToTagClass(specsText);
            const evalCls = statusToTagClass(evalText);
            div.innerHTML = `<div class="k">${who} • ${r.assignment_type || ''} • ${r.created_at ? new Date(r.created_at).toLocaleDateString() : ''}</div>
                             <div class="v"><span class="tag ${tag}">${specsText}</span> &nbsp; <span title="Your evaluation" class="tag ${evalCls}">${evalText}</span></div>
                             <div class="k" style="grid-column:1 / -1; color: var(--muted);">${(r.comments || '').slice(0,280)}</div>`;
            reflReceived.appendChild(div);
          }
        } catch {}
        finally {
          const legend = document.getElementById('reflReceivedLegend');
          if (legend && reflReceived.children.length === 0) legend.style.display = 'none';
        }
      }

      function buildReflReviewForm(classmates) {
        const wrap = document.createElement('div');
        wrap.className = 'group-box';
        const sel = document.createElement('select'); sel.name = 'revieweeId'; sel.setAttribute('aria-label','Select classmate to review'); sel.id = `reflRevieweeId_${Math.random().toString(36).slice(2)}`;
        for (const s of classmates) {
          const opt = document.createElement('option'); opt.value = s.id; opt.textContent = s.full_name || s.email || s.id; sel.appendChild(opt);
        }
        const ta = document.createElement('textarea'); ta.rows = 6; ta.placeholder = 'Write your comments...'; ta.name = 'reviewComments'; ta.setAttribute('aria-label','Review comments'); ta.id = `reflReviewComments_${Math.random().toString(36).slice(2)}`;
        try { attachNoPaste(ta, { message: 'Paste is disabled in review comments to encourage authentic feedback.' }); attachAntiAutoType(ta); } catch {}
        const spec = document.createElement('select'); spec.name = 'reviewSpecs'; spec.setAttribute('aria-label','Specs evaluation'); spec.id = `reflReviewSpecs_${Math.random().toString(36).slice(2)}`;
        ['A Level: Exceeding','B Level: Meeting Expectations','C Level: Approaching Expectations'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; spec.appendChild(o); });
        const submit = document.createElement('button'); submit.type='button'; submit.textContent='Submit Review';
        const msg = document.createElement('div'); msg.className='muted'; msg.style.marginTop='6px';
        wrap.appendChild(Object.assign(document.createElement('div'), { innerHTML: `<div class="group-title"><strong>New Review</strong><span class="muted">Reflections</span></div>` }));
        const classmateLbl = document.createElement('label'); classmateLbl.textContent = 'Select classmate'; classmateLbl.htmlFor = sel.id; wrap.appendChild(classmateLbl);
        wrap.appendChild(sel);
        const cmLbl = document.createElement('label'); cmLbl.textContent = 'Comments'; cmLbl.htmlFor = ta.id; wrap.appendChild(cmLbl);
        wrap.appendChild(ta);
        const spLbl = document.createElement('label'); spLbl.textContent = 'Specs Evaluation'; spLbl.htmlFor = spec.id; wrap.appendChild(spLbl);
        wrap.appendChild(spec);
        wrap.appendChild(submit);
        wrap.appendChild(msg);
    submit.addEventListener('click', async ()=>{
          const reviewee = sel.value; const comments = ta.value.trim(); const specsVal = spec.value; msg.textContent='Saving…';
          try {
      // To avoid 400s on schemas without assignment_type, store a tag in comments
      const fb = { reviewer_id: user.id, reviewee_id: reviewee, comments: `[Reflections] ${comments}`, specs: specsVal };
      const r2 = await supabase.from(PEER_REVIEWS_TABLE).insert(fb, { returning:'minimal' });
      if (r2.error) throw r2.error;
            msg.textContent='Review submitted.'; await loadReflReceived();
          } catch { msg.textContent='Could not save review (tables or RLS may not be configured).'; }
        });
        return wrap;
      }

      async function addReflReviewForm() {
        const classmates = await getClassmates();
        if (!classmates.length) {
          const d = document.createElement('div'); d.className='muted'; d.textContent='No classmates available.'; reflReviewForms.appendChild(d); return;
        }
        const form = buildReflReviewForm(classmates);
        reflReviewForms.appendChild(form);
      }

      addReflReviewFormBtn?.addEventListener('click', async ()=>{ await addReflReviewForm(); });

      reflSubmitForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!reflSubmitMsg) return;
        reflSubmitMsg.textContent = '';
        const text = (reflText?.value || '').trim();
        const title = (reflTitle?.value || 'Reflection 1');
        if (!PEER_SUBMISSIONS_EXISTS) { reflSubmitMsg.textContent = 'Reflections submissions are not available in this deployment.'; return; }
        if (!text) { reflSubmitMsg.textContent = 'Please type your reflection.'; return; }
        try {
          // Avoid using assignment_type in case the column isn't present
          let payload = { student_id: user.id, text: text, title };
          let { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).insert({ ...payload, assignment_type: 'Reflections' }, { returning:'minimal' });
          if (error) {
            // Fallback: tag the text if column is missing
            const prefixed = `[Reflections] ${title}\n${text}`;
            const fb = { student_id: user.id, text: prefixed, title };
            const r2 = await supabase.from(PEER_SUBMISSIONS_TABLE).insert(fb, { returning:'minimal' });
            if (r2.error) throw r2.error;
          }
          reflSubmitMsg.textContent = 'Submission saved.';
          if (reflText) reflText.value='';
        } catch { reflSubmitMsg.textContent = 'Could not save submission (tables, storage, or RLS may not be configured).'; }
      });
      function guessTitleFromText(s) {
        // naive: take first line if present
        const lines = (s||'').split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
        return lines[0] || null;
      }
    async function loadMyPortfolio() {
        if (!myPortfolioList) return;
        myPortfolioList.innerHTML = '';
        myPortfolioEmpty.style.display = '';
        try {
          if (!PEER_SUBMISSIONS_EXISTS) { myPortfolioEmpty.style.display = ''; return; }
          const { data, error: psErr2 } = await supabase.from(PEER_SUBMISSIONS_TABLE).select('id, created_at, assignment_type, file_path, text, category, title, url').eq('student_id', user.id).eq('assignment_type','Professional Portfolio').order('created_at',{ascending:false});
          if (psErr2) { PEER_SUBMISSIONS_EXISTS = false; return; }
          const rows = data || [];
          if (!rows.length) return;
          myPortfolioEmpty.style.display = 'none';
          for (const r of rows) {
            const div = document.createElement('div');
            div.className = 'kv';
            const cat = r.category || guessCategoryFromText(r.text) || 'Portfolio';
            const ttl = r.title || guessTitleFromText(r.text) || '';
            const date = new Date(r.created_at).toLocaleDateString();
            const fileLink = r.file_path ? `<a href="#" data-path="${r.file_path}" class="file-link" style="color:#a5b4fc;">file</a>` : '';
            const urlLink = r.url ? `<a href="#" data-url="${r.url}" class="url-link" style="color:#a5b4fc;">link</a>` : '';
            const links = [fileLink, urlLink].filter(Boolean).join(' · ');
            div.innerHTML = `<div class="k">${cat}${ttl? ' • '+ttl:''}</div>
                             <div class="v">${date} ${links}
                               <button data-action="delete" aria-label="Delete portfolio item" style="margin-left:8px; border-color:#7f1d1d;">Delete</button>
                               <span class="muted" data-role="msg" style="margin-left:6px;"></span>
                             </div>`;
            // Optional: open file via signed URL (best effort)
            if (r.file_path) {
              div.querySelector('a.file-link')?.addEventListener('click', async (ev)=>{
                ev.preventDefault();
                try {
                  const { data: urlData } = await supabase.storage.from('peer-submissions').createSignedUrl(r.file_path, 3600);
                  if (urlData?.signedUrl) window.open(urlData.signedUrl, '_blank');
                } catch {}
              });
            }
            if (r.url) {
              div.querySelector('a.url-link')?.addEventListener('click', (ev)=>{
                ev.preventDefault();
                window.open(r.url, '_blank');
              });
            }
            // Allow student to delete their own item (best-effort; subject to RLS)
            const delBtn = div.querySelector('button[data-action="delete"]');
            const msg = div.querySelector('[data-role="msg"]');
            delBtn?.addEventListener('click', async () => {
              if (!confirm('Delete this portfolio item? This will remove the DB row and the file if present.')) return;
              if (msg) msg.textContent = 'Deleting…';
              try {
                if (r.file_path) { try { await supabase.storage.from('peer-submissions').remove([r.file_path]); } catch {}
                }
                const { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).delete().eq('id', r.id);
                if (error) throw error;
                if (msg) msg.textContent = 'Deleted.';
                await loadMyPortfolio();
              } catch { if (msg) msg.textContent = 'Delete failed (RLS/policies).'; }
            });
            myPortfolioList.appendChild(div);
          }
        } catch {}
      }

      // ---------- Portfolio Admin (Delete/Replace) ----------
      let _portfolioAdminCache = { studs: [], subs: [] };
      async function initPortfolioAdmin() {
        if (!isAdmin || !portfolioAdmin) return;
        if (!PEER_SUBMISSIONS_EXISTS) { portfolioAdmin.style.display = 'none'; return; }
        // Populate section filter
        const sections = await fetchSections();
        portfolioAdminSectionSelect.innerHTML = '';
        for (const s of sections) {
          const o = document.createElement('option'); o.value = s; o.textContent = s; portfolioAdminSectionSelect.appendChild(o);
        }
        const preferred = currentProfile?.section && sections.includes(currentProfile.section) ? currentProfile.section : sections[0];
        if (preferred) portfolioAdminSectionSelect.value = preferred;
        const trigger = () => loadPortfolioAdmin(true);
        portfolioAdminSectionSelect.addEventListener('change', trigger);
        portfolioAdminSearchInput?.addEventListener('input', () => loadPortfolioAdmin(false));
        portfolioAdminCategorySelect?.addEventListener('change', () => loadPortfolioAdmin(false));
        await loadPortfolioAdmin(true);
      }

    async function loadPortfolioAdmin(reload = false) {
        portfolioAdminList.innerHTML = '';
        portfolioAdminMsg.textContent = '';
        const section = portfolioAdminSectionSelect.value;
        try {
      if (!PEER_SUBMISSIONS_EXISTS) { portfolioAdminMsg.textContent = 'Portfolio features are not available.'; return; }
          // get students/subs with caching
          if (reload || !_portfolioAdminCache.studs.length) {
            const { data: studs } = await supabase.from('students').select('id, full_name, email').eq('section', section).order('full_name');
            _portfolioAdminCache.studs = studs || [];
            const ids = _portfolioAdminCache.studs.map(s => s.id);
            if (!ids.length) { portfolioAdminMsg.textContent = 'No students in this section.'; return; }
            const { data: subs, error: psErr3 } = await supabase
              .from(PEER_SUBMISSIONS_TABLE)
              .select('id, created_at, student_id, assignment_type, category, title, file_path, text, url')
              .in('student_id', ids)
              .eq('assignment_type','Professional Portfolio')
              .order('created_at', { ascending:false });
            if (psErr3) { PEER_SUBMISSIONS_EXISTS = false; portfolioAdminMsg.textContent = 'Portfolio features are not available.'; return; }
            _portfolioAdminCache.subs = subs || [];
          }
          const studs = _portfolioAdminCache.studs;
          let subs = _portfolioAdminCache.subs.slice();
          const byId = new Map(studs.map(s => [s.id, s]));
          // filters
          const q = (portfolioAdminSearchInput?.value || '').trim().toLowerCase();
          if (q) {
            const match = (s) => (s.full_name||'').toLowerCase().includes(q) || (s.email||'').toLowerCase().includes(q);
            const allowed = new Set(studs.filter(match).map(s => s.id));
            subs = subs.filter(r => allowed.has(r.student_id));
          }
          const cat = (portfolioAdminCategorySelect?.value || '').trim();
          if (cat) subs = subs.filter(r => (r.category||'') === cat);
          if (!subs.length) { portfolioAdminMsg.textContent = 'No items match your filters.'; return; }
          for (const r of subs) {
            const owner = byId.get(r.student_id);
            const holder = document.createElement('div');
            holder.className = 'group-box';
            const cat = r.category || guessCategoryFromText(r.text) || 'Portfolio';
            const ttl = r.title || guessTitleFromText(r.text) || '';
            const date = new Date(r.created_at).toLocaleDateString();
            holder.innerHTML = `
              <div class="group-title"><strong>${owner?.full_name || owner?.email || r.student_id}</strong><span class="muted">${date}</span></div>
              <div class="muted" style="margin-bottom:6px;">${cat}${ttl? ' • '+ttl:''}</div>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                <button data-action="open" aria-label="Open submission">Open</button>
                <button data-action="replace" aria-label="Replace file">Replace File</button>
                <button data-action="delete" aria-label="Delete submission" style="border-color:#7f1d1d;">Delete</button>
                <input type="file" name="replacementFile" aria-label="Replacement file" style="display:none;" />
                <span class="muted" data-role="msg"></span>
              </div>
            `;
            const openBtn = holder.querySelector('button[data-action="open"]');
            const replaceBtn = holder.querySelector('button[data-action="replace"]');
            const deleteBtn = holder.querySelector('button[data-action="delete"]');
            const fileInput = holder.querySelector('input[type="file"]');
            const msg = holder.querySelector('[data-role="msg"]');
            openBtn.addEventListener('click', async () => {
              msg.textContent = 'Opening…';
              try {
                if (r.file_path) {
                  const { data: urlData } = await supabase.storage.from('peer-submissions').createSignedUrl(r.file_path, 3600);
                  if (urlData?.signedUrl) window.open(urlData.signedUrl, '_blank');
                } else if (r.url) {
                  window.open(r.url, '_blank');
                } else if (r.text) {
                  const w = window.open('', '_blank');
                  if (w) {
                    w.document.write(`<pre style="white-space:pre-wrap; font-family:system-ui; padding:16px;">${(r.text||'').replace(/[&<>]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]))}</pre>`);
                    w.document.close();
                  }
                } else {
                  msg.textContent = 'No file/text to open.';
                }
              } catch { msg.textContent = 'Open failed.'; }
            });
            replaceBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', async () => {
              const file = fileInput.files?.[0]; if (!file) return;
              msg.textContent = 'Uploading…';
              try {
                const newPath = `${r.student_id}/${Date.now()}_${file.name}`;
                const { error: upErr } = await supabase.storage.from('peer-submissions').upload(newPath, file, { upsert: false });
                if (upErr) throw upErr;
                // Update submission with new file_path
                let { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).update({ file_path: newPath }).eq('id', r.id);
                if (error) throw error;
                // Optionally delete old file (best-effort)
                if (r.file_path) { try { await supabase.storage.from('peer-submissions').remove([r.file_path]); } catch {}
                }
                msg.textContent = 'Replaced.';
                await loadPortfolioAdmin();
              } catch { msg.textContent = 'Replace failed (RLS/storage).'; }
            });
            deleteBtn.addEventListener('click', async () => {
              if (!confirm('Delete this portfolio item? This will remove the DB row and the file if present.')) return;
              msg.textContent = 'Deleting…';
              try {
                // Best-effort: delete file first
                if (r.file_path) { try { await supabase.storage.from('peer-submissions').remove([r.file_path]); } catch {}
                }
                // Delete DB row
                const { error } = await supabase.from(PEER_SUBMISSIONS_TABLE).delete().eq('id', r.id);
                if (error) throw error;
                msg.textContent = 'Deleted.';
                await loadPortfolioAdmin();
              } catch { msg.textContent = 'Delete failed (RLS/policies).'; }
            });
            portfolioAdminList.appendChild(holder);
          }
        } catch { portfolioAdminMsg.textContent = 'Could not load portfolio items.'; }
      }
    </script>
  </body>
</html>
